// controllers/denverLiveOccupancyController.js

const { DateTime }       = require('luxon');
// const { denver }         = require('../config/siteConfig');
const { denver } = require('../config/siteConfig');
const doorFloorMap       = require('../data/denverDoorFloorMap');
const { monitoredDoors } = require('../data/strictDoorList');
const sql                = require('mssql');
const normalizeKey = require('../data/normalizeKey');

const warnedKeys = new Set();


// build a Set of normalized door___direction keys
const normalizedMonitoredKeys = new Set(
  Object.entries(monitoredDoors).map(
    ([door, dir]) => normalizeKey(door, dir)
  )
);

/** Determine floor label, fallback to ‚ÄúHQ. N.‚Äù parsing **/
function mapDoorToFloor(rawDoor, rawDir) {
  const key = normalizeKey(rawDoor, rawDir);
  if (doorFloorMap[key]) return doorFloorMap[key];
  const m = rawDoor.match(/HQ\.\s*(\d{1,2})\b/);
  if (m) return `Floor ${m[1]}`;
  if (!warnedKeys.has(key)) {
    console.warn(`‚õî Unmapped door-floor key: "${key}"`);
    warnedKeys.add(key);
  }
  return 'Unknown Floor';
}

/** Strip any trailing ‚Äú_HH:MM:SS‚Äù from a door name **/
function stripTimeSuffix(doorRaw) {
  return doorRaw.replace(/_[0-9]{2}:[0-9]{2}:[0-9]{2}$/, '');
}


async function fetchNewEvents(since) {
  // 1) Acquire the pool. If it fails, we‚Äôll catch below.
  let pool;
  try {
    pool = await denver.poolPromise;
  } catch (err) {
    console.error('‚ùå Failed to get Denver pool in fetchNewEvents():', err);
    return [];
  }
  if (!pool) {
    // If poolPromise ultimately returned null, just bail out with an empty array.
    return [];
  }

 const req = pool.request();
  req.input('since', sql.DateTime2, since);


  const { recordset } = await req.query(`
    WITH CombinedQuery AS (
      SELECT
          DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,    
        t1.ObjectName1,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]' ,'varchar(50)'),
          sc.value
        ) AS CardNumber,
        t5a.value AS AdmitCode,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM ACVSUJournal_00010027.dbo.ACVSUJournalLog t1
      LEFT JOIN ACVSCore.Access.Personnel     t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN ACVSCore.Access.PersonnelType t3 ON t2.PersonnelTypeId  = t3.ObjectID
      LEFT JOIN ACVSUJournal_00010027.dbo.ACVSUJournalLogxmlShred t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN ACVSUJournal_00010027.dbo.ACVSUJournalLogxmlShred t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Name = 'Direction'
      LEFT JOIN ACVSUJournal_00010027.dbo.ACVSUJournalLogxml t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM ACVSUJournal_00010027.dbo.ACVSUJournalLogxmlShred
        WHERE Name IN ('Card','CHUID')
      ) sc ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType   = 'CardAdmitted'
        AND t1.ObjectName2 LIKE '%HQ%'
        AND DATEADD(MINUTE,-1* t1.MessageLocaleOffset, t1.MessageUTC) >=@since
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8),  LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID, PersonGUID, ObjectName1, PersonnelType,
      CardNumber, AdmitCode, Direction, Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);

  return recordset;
}

function isTodayInDenver(dateOnly) {
  const swipeDate = DateTime.fromISO(dateOnly, { zone: 'America/Denver' })
    .toFormat('yyyy-LL-dd');
  const today = DateTime.now().setZone('America/Denver').toFormat('yyyy-LL-dd');
  return swipeDate === today;
}

/**
 * Build live occupancy + swipe summaries.
 * @param {Array} allEvents   ‚Äì cumulative events (for occupancy)
 * @param {Array} freshEvents ‚Äì just-fetched events (for swipeStats & floorInOut)
 */


function computeVisitedToday(allEvents) {
  const seen = new Map(); // key -> PersonnelType
  allEvents.forEach(evt => {
    if (evt.Direction === 'InDirection' && isTodayInDenver(evt.Dateonly)) {
      const key = evt.PersonGUID || evt.EmployeeID || evt.CardNumber;
      if (!seen.has(key)) {
        seen.set(key, evt.PersonnelType);
      }
    }
  });
  let emp = 0, ctr = 0;
  seen.forEach(type => {
    if (type === 'Employee' || type === 'Terminated Personnel') emp++;
    else ctr++;
  });
  return { total: seen.size, employees: emp, contractors: ctr };
}



function buildOccupancyForToday(allEvents, freshEvents) {
  // ‚îÄ‚îÄ‚îÄ A) Evict ‚ÄúOut of office‚Äù ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const evicted = new Set();
  const lastByPerson = new Map();
  allEvents.forEach(evt => {
    if (!isTodayInDenver(evt.Dateonly)) return;
    const key = evt.PersonGUID || evt.EmployeeID || evt.CardNumber;
    const prev = lastByPerson.get(key);
    if (!prev || evt.LocaleMessageTime > prev.LocaleMessageTime) {
      lastByPerson.set(key, evt);
    }
  });
  lastByPerson.forEach(evt => {
    if (
      evt.Direction === 'OutDirection'
      && mapDoorToFloor(evt.Door, evt.Direction) === 'Out of office'
    ) {
      evicted.add(evt.PersonGUID || evt.EmployeeID || evt.CardNumber);
    }
  });
  const activeEvents = allEvents.filter(evt => {
    const key = evt.PersonGUID || evt.EmployeeID || evt.CardNumber;
    return !evicted.has(key);
  });



  // ‚îÄ‚îÄ‚îÄ 1) Live occupancy dedupe by last InDirection ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const todayIn = activeEvents.filter(e =>
    e.Direction === 'InDirection' && isTodayInDenver(e.Dateonly)
  );
  const latestByPerson = new Map();
  todayIn.forEach(e => {
    const prev = latestByPerson.get(e.PersonGUID);
    const tcur = DateTime.fromFormat(e.Swipe_Time, 'HH:mm:ss');
    if (!prev || tcur > DateTime.fromFormat(prev.Swipe_Time, 'HH:mm:ss')) {
      latestByPerson.set(e.PersonGUID, e);
    }
  });
  const finalList = Array.from(latestByPerson.values());


 // ‚îÄ‚îÄ‚îÄ 2) Floor breakdown & personnel counts (live) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  let employees = 0, contractors = 0;
  const floorMap = {};
  finalList.forEach(e => {
    // const floor = mapDoorToFloor(evt.Door, evt.Direction);
    const fl = mapDoorToFloor(e.Door, e.Direction);
    floorMap[fl] = floorMap[fl] || [];
    floorMap[fl].push(e);
    if (e.PersonnelType === 'Employee' || e.PersonnelType === 'Terminated Personnel') {
      employees++;
    } else {
      contractors++;
    }
  });



const floorBreakdown = Object.entries(floorMap).map(([floor, occ]) => {
  // Initialize counters
  let empCount    = 0;
  let contractorCount = 0;
  let tempBadgeCount  = 0;
  let otherCount      = 0;

  occ.forEach(e => {
    switch (e.PersonnelType) {
      case 'Employee':
      case 'Terminated Personnel':
        empCount++;
        break;
      case 'Contractor':
      case 'Terminated Contractor':
        contractorCount++;
        break;
      case 'Temp Badge':
        tempBadgeCount++;
        break;
      default:
        otherCount++;
    }
  });

  return {
    floor,
    total:       occ.length,
    employees:   empCount,
    contractors: contractorCount,
    tempBadge:   tempBadgeCount,
    others:      otherCount,   // optional, in case you have Visitors etc.
    occupants:   occ
  };
});



  // ‚îÄ‚îÄ‚îÄ 3) Personnel breakdown ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const personnelBreakdown = Array.from(
    finalList.reduce((m, e) => {
      m.set(e.PersonnelType, (m.get(e.PersonnelType) || 0) + 1);
      return m;
    }, new Map()),
    ([personnelType, count]) => ({ personnelType, count })
  );



  // ‚îÄ‚îÄ‚îÄ 4) Swipe stats (fresh only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const totalInSwipes  = freshEvents.filter(e =>
    e.Direction === 'InDirection' && isTodayInDenver(e.Dateonly)
  ).length;
  const totalOutSwipes = freshEvents.filter(e =>
    e.Direction === 'OutDirection' && isTodayInDenver(e.Dateonly)
  ).length;




// ‚îÄ‚îÄ‚îÄ 5) Floor In/Out summary (strict doors only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const validEvents = allEvents
  .filter(e => isTodayInDenver(e.Dateonly))
  .filter(evt => {
    // 1) strip any "_HH:MM:SS" suffix
    const doorNoTime = stripTimeSuffix(evt.Door.trim());
    // 2) normalize to KEY___IN or KEY___OUT
    const key = normalizeKey(doorNoTime, evt.Direction.trim());
    // 3) only keep if it‚Äôs exactly in your strict list
    return normalizedMonitoredKeys.has(key);
  });

// Dedupe per person+floor+direction
const deduped = new Map();
validEvents.forEach(evt => {
  // Determine floor by regex (not via doorFloorMap, to avoid "Out of office")
  const rawNoTime = stripTimeSuffix(evt.Door);
  const m = rawNoTime.match(/HQ\.\s*(\d{1,2})\b/);
  const floor = m ? `Floor ${m[1]}` : 'Unknown Floor';

  const mapKey = `${evt.PersonGUID || evt.EmployeeID}___${floor}___${evt.Direction}`;
  const prev   = deduped.get(mapKey);
  const now    = DateTime.fromFormat(evt.Swipe_Time, 'HH:mm:ss');
  if (!prev || now > DateTime.fromFormat(prev.Swipe_Time, 'HH:mm:ss')) {
    deduped.set(mapKey, evt);
  }
});

// Aggregate inSwipes/outSwipes per floor
const floorMapIO = {};
for (const evt of deduped.values()) {
  const rawNoTime = stripTimeSuffix(evt.Door);
  const m = rawNoTime.match(/HQ\.\s*(\d{1,2})\b/);
  const floor = m ? `Floor ${m[1]}` : 'Unknown Floor';

  if (!floorMapIO[floor]) {
    floorMapIO[floor] = {
      inSwipes:  0,
      outSwipes: 0,
      inSet:     new Set(),
      outSet:    new Set()
    };
  }

  const id = evt.PersonGUID || evt.EmployeeID || evt.CardNumber;
  if (evt.Direction === 'InDirection') {
    floorMapIO[floor].inSwipes++;
    floorMapIO[floor].inSet.add(id);
  } else {
    floorMapIO[floor].outSwipes++;
    floorMapIO[floor].outSet.add(id);
  }
}

// Build your final summary
const floorInOutSummary = Object.entries(floorMapIO).map(([floor, stats]) => {
  const inOnly = [...stats.inSet].filter(id => !stats.outSet.has(id));
  return {
    floor,
    inSwipes:      stats.inSwipes,
    outSwipes:     stats.outSwipes,
    inOnlyCount:   inOnly.length,
    inOnlyPersons: inOnly
  };
});





    // ‚îÄ‚îÄ‚îÄ 6) Visited today breakdown ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const visited = computeVisitedToday(allEvents);

  return {
    asOf:               new Date().toISOString(),
    currentCount:       finalList.length,
    floorBreakdown,
    personnelSummary:   { employees, contractors },
    personnelBreakdown,
    totalVisitedToday:  visited.total,
    visitedToday:       {
      employees:   visited.employees,
      contractors: visited.contractors,
      total:       visited.total
    },
    swipeStats:         { totalInSwipes, totalOutSwipes },
    floorInOutSummary   // unchanged
  };
}


exports.getDenverLiveOccupancy = async (req, res) => {

 try {
    await denver.poolPromise;
  } catch (err) {
    console.error('‚ùå Failed to initialize Denver pool in SSE endpoint:', err);
    // If we can‚Äôt even get a pool, return 500 and abort.
    return res.status(500).end();
  }


  //  await denver.poolPromise;

  res.writeHead(200, {
    'Content-Type':  'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection':    'keep-alive'
  });
  res.write('\n');

  let lastSeen = new Date(Date.now() - 24 * 60 * 60 * 1000);
  const events = [];



const push = async () => {
    let fresh;
    try {
      fresh = await fetchNewEvents(lastSeen);
    } catch (err) {
      console.error('‚ùå Error in fetchNewEvents():', err);
      fresh = [];
    }

    if (Array.isArray(fresh) && fresh.length) {
      lastSeen = fresh[fresh.length - 1].LocaleMessageTime;
      events.push(...fresh);
    }

    let payload;
    try {
      payload = buildOccupancyForToday(events, fresh);
    } catch (err) {
      console.error('‚ùå Error building Denver occupancy payload:', err);
      payload = {
        asOf: new Date().toISOString(),
        currentCount: 0,
        floorBreakdown: [],
        personnelSummary: { employees: 0, contractors: 0 },
        personnelBreakdown: [],
        totalVisitedToday: 0,
        visitedToday: { employees: 0, contractors: 0, total: 0 },
        swipeStats: { totalInSwipes: 0, totalOutSwipes: 0 },
        floorInOutSummary: []
      };
    }

    // res.write(`data: ${JSON.stringify(payload)}\n\n`);

    // tag with a unique id and flush right away
    const sid = Date.now();
    res.write(`id: ${sid}\n`);
    res.write(`data: ${JSON.stringify(payload)}\n\n`);
    if (typeof res.flush === 'function') {
      res.flush();
    }

  };

  await push();
  const timer = setInterval(push, 1000);
  req.on('close', () => clearInterval(timer));
};












// controllers/liveOccupancyController.js


const { DateTime }   = require('luxon');
// const { poolConnect, pool, sql } = require('../config/db');
const { sql, getPool } = require('../config/db');

const doorZoneMap    = require('../data/doorZoneMap');
const zoneFloorMap   = require('../data/zoneFloorMap');

const ertMembers = require('../data/puneErtMembers.json');

// track which door‚Üízone keys we've already warned on
const warnedKeys = new Set();

//update
function getTodayString() {
  return DateTime.now()
    .setZone('Asia/Kolkata')
    .toFormat('yyyy-LL-dd');
}




function normalizeZoneKey(rawDoor, rawDir) {
  // 1) Ensure it‚Äôs a string and trim whitespace
  let door = String(rawDoor || '').trim();

  // 2) Strip any "_HH:MM:SS" or "_XX:XX:XX" suffix (hex codes or times at end)
  door = door.replace(/_[0-9A-F]{2}:[0-9A-F]{2}:[0-9A-F]{2}$/, '');

  // 3) Collapse multiple spaces into one, then uppercase
  door = door.replace(/\s+/g, ' ').toUpperCase();

  // 4) Pick the direction token exactly as doorZoneMap expects
  const dir = rawDir === 'InDirection' ? 'InDirection' : 'OutDirection';

  return `${door}___${dir}`;
}

/** Normalize "Last, First" or "First Last" ‚Üí lowercase "first last" */
function normalizePersonName(raw) {
  let n = String(raw || '').trim();
  if (n.includes(',')) {
    const [last, rest] = n.split(',', 2);
    n = `${rest.trim()} ${last.trim()}`;
  }
  return n.toLowerCase();
}

/**
 * Map a swipe‚Äôs door+direction ‚Üí zone using exactly doorZoneMap.
 * If not in doorZoneMap, log once and return "Unknown Zone".
 * If OutDirection but not "Out of office", strip off " Zone" suffix.
 */
function mapDoorToZone(rawDoor, rawDir) {
  const key = normalizeZoneKey(rawDoor, rawDir);
  const zone = doorZoneMap[key];

  if (!zone) {
    if (!warnedKeys.has(key)) {
      console.warn('‚õî Unmapped door‚Äìdirection key:', key);
      warnedKeys.add(key);
    }
    return 'Unknown Zone';
  }

  // If it's an OutDirection but not the real "Out of office", remove trailing " Zone"
  if (rawDir === 'OutDirection' && zone !== 'Out of office') {
    return zone.replace(/\s+Zone$/i, '');
  }

  return zone;
}


async function fetchNewEvents(since) {
  // await the shared pool promise instead of poolConnect
  const pool = await getPool();
  const req  = pool.request();
  req.input('since', sql.DateTime2, since);

// console.log('üîé [Pune] fetchNewEvents called with since =', since.toISOString());
  const { recordset } = await req.query(`
    WITH CombinedQuery AS (
      SELECT
       DATEADD(MINUTE,-1 *t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
       


        t1.ObjectName1,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          sc.value
        ) AS CardNumber,
        t5a.value AS AdmitCode,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxml] t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred]
        WHERE Name IN ('Card','CHUID')
      ) sc ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType     = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) >= @since
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8) , LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID,
      PersonGUID,
      ObjectName1,
      PersonnelType,
      CardNumber,
      AdmitCode,
      Direction,
      Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);

  // console.log(`üì• [Pune] fetched ${recordset.length} rows:`,
    // recordset.map(r => r.LocaleMessageTime.toISOString()));

  return recordset;
}



async function buildOccupancy(allEvents) {
  const current      = {};
  const uniquePeople = new Map();

  for (const evt of allEvents) {
    const {
      EmployeeID, PersonGUID,
      ObjectName1, PersonnelType,
      CardNumber, Dateonly,
      Swipe_Time, Direction, Door
    } = evt;

    const dedupKey = PersonGUID || EmployeeID || CardNumber || ObjectName1;
    const zoneRaw  = mapDoorToZone(Door, Direction);
    const zone     = zoneRaw && zoneRaw.toLowerCase();

 // ‚îÄ‚îÄ‚îÄ 1) If we can‚Äôt map door+direction to a valid zone, skip this event entirely. ‚îÄ‚îÄ‚îÄ
    //     (prevents "Unknown Zone" from ever entering uniquePeople/current)
    if (zoneRaw === 'Unknown Zone') {
      // We warned once in mapDoorToZone already; just ignore.
      continue;
    }

    const zoneLower = zoneRaw.toLowerCase();



    // 1) True "Out of office" ‚Üí full eviction
    if (Direction === 'OutDirection' && zone === 'out of office') {
      uniquePeople.delete(dedupKey);
      delete current[dedupKey];
      continue;
    }



    // ‚îÄ‚îÄ‚îÄ 2) Other OutDirection ‚Üí maybe eviction, maybe keep
    if (Direction === 'OutDirection') {
      // If this OutDirection is genuinely ‚ÄúOuter Area,‚Äù keep them:
      if (zone.toLowerCase()) {
        uniquePeople.set(dedupKey, PersonnelType);
        current[dedupKey] = {
          Dateonly, Swipe_Time,
          EmployeeID, ObjectName1, CardNumber,
          PersonnelType,
          zone: zoneRaw,
          door: Door,
          Direction
        };
      } else {
        // Any other OutDirection (TURNSTILE, lobby exits, etc.) = full eviction
        uniquePeople.delete(dedupKey);
        delete current[dedupKey];
      }
      continue;
    }



    // 3) InDirection ‚Üí normal check-in
    if (Direction === 'InDirection') {
      uniquePeople.set(dedupKey, PersonnelType);
      current[dedupKey] = {
        Dateonly, Swipe_Time,
        EmployeeID, ObjectName1, CardNumber,
        PersonnelType,
        zone: zoneRaw,
        door: Door,
        Direction
      };
      continue;
    }

    // 4) Catch-all eviction
    uniquePeople.delete(dedupKey);
    delete current[dedupKey];
  }

  // live headcounts (only from uniquePeople, which has already evicted all true out-of-office)
  let employeeCount   = 0;
  let contractorCount = 0;
  for (const pt of uniquePeople.values()) {
    if (['Employee','Terminated Personnel'].includes(pt)) employeeCount++;
    else contractorCount++;
  }

  // Build zone‚Üípeople map, but filter out any out-of-office at this final step too
  const zoneMap = {};
  for (const emp of Object.values(current)) {
    const zKey = emp.zone.toLowerCase();
    if (zKey === 'out of office') continue;
    zoneMap[emp.zone] = zoneMap[emp.zone] || [];
    zoneMap[emp.zone].push(emp);
  }

  // zoneDetails
  const zoneDetails = Object.fromEntries(
    Object.entries(zoneMap).map(([zone, emps]) => {
      const byType = emps.reduce((acc, e) => {
        acc[e.PersonnelType] = (acc[e.PersonnelType]||0) + 1;
        return acc;
      }, {});
      return [ zone, { total: emps.length, byPersonnelType: byType, employees: emps } ];
    })
  );

  // floorBreakdown
  const floorMap = {};
  for (const [zone, data] of Object.entries(zoneDetails)) {
    const floor = zoneFloorMap[zone] || 'Unknown Floor';
    floorMap[floor] = floorMap[floor] || { total: 0, byPersonnelType: {} };
    floorMap[floor].total += data.total;
    for (const [pt, c] of Object.entries(data.byPersonnelType)) {
      floorMap[floor].byPersonnelType[pt] = (floorMap[floor].byPersonnelType[pt]||0) + c;
    }
  }



  // const ertStatus = Object.fromEntries(
  //   Object.entries(ertMembers).map(([role, members]) => {
  //     const list = members.map(m => {
  //       const expected = normalizePersonName(m.name);


  const ertStatus = Object.fromEntries(
    Object.entries(ertMembers).map(([role, members]) => {
      const list = members.map(m => {
        // pick the correct name field (JSON uses "Name")
        const rawName = m.name || m.Name;
        const expected = normalizePersonName(rawName);


        // find a matching swipe in current[]
        const matchEvt = Object.values(current).find(e => {
          return normalizePersonName(e.ObjectName1) === expected;
        });

        return {
          ...m,
          present: !!matchEvt,
          zone:    matchEvt ? matchEvt.zone : null
        };
     });
      return [ role, list ];
    })
  );



  return {
    asOf:             new Date().toISOString(),
    summary:          Object.entries(zoneDetails).map(([z,d])=>({ zone: z, count: d.total })),
    zoneBreakdown:    Object.entries(zoneDetails).map(([z,d])=>({ zone: z, ...d.byPersonnelType, total: d.total })),
    floorBreakdown:   Object.entries(floorMap).map(([f,d])=>({ floor: f, ...d.byPersonnelType, total: d.total })),
    details:          zoneMap,
    personnelSummary: { employees: employeeCount, contractors: contractorCount },
     ertStatus,
  

  personnelBreakdown: (() => {
    const map = new Map();
    // uniquePeople: Map<dedupKey, PersonnelType>
    for (const pt of uniquePeople.values()) {
      map.set(pt, (map.get(pt) || 0) + 1);
    }
    return Array.from(map, ([personnelType, count]) => ({ personnelType, count }));
  })(),



  };
}


/**
 * Build ‚Äúvisited today‚Äù from the same in‚Äêmemory stream
 */
function buildVisitedToday(allEvents) {
  // ‚ÄúToday‚Äù in Asia/Kolkata, formatted as ‚Äúyyyy-MM-dd‚Äù
  const today = DateTime.now()
    .setZone('Asia/Kolkata')
    .toFormat('yyyy-LL-dd');

  // Use evt.Dateonly (already ‚Äúyyyy-MM-dd‚Äù in local zone) to pick out today's InDirection swipes
  const todayIns = allEvents.filter(evt => {
    return (
      evt.Direction === 'InDirection' &&
      evt.Dateonly === today
    );
  });

  // Dedupe by PersonGUID ‚Üí keep the latest swipe
  const dedup = new Map();
  for (const e of todayIns) {
    const key = e.PersonGUID;
    const prev = dedup.get(key);
    if (!prev || e.LocaleMessageTime > prev.LocaleMessageTime) {
      dedup.set(key, e);
    }
  }

  const finalList = Array.from(dedup.values());

  // Separate employees vs contractors
  const employees = finalList.filter(e =>
    !['Contractor','Terminated Contractor','Temp Badge','Visitor','Property Management']
      .includes(e.PersonnelType)
  ).length;
  const contractors = finalList.length - employees;

  return { employees, contractors, total: finalList.length };
}



/** Server‚ÄêSent‚ÄêEvents endpoint */
exports.getLiveOccupancy = async (req, res) => {
 

  try {
    // wait for the shared pool to be ready
    await getPool();

    res.writeHead(200, {
      'Content-Type':  'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection':    'keep-alive'
    });
    res.write('\n');

    // pull last 24h on startup
    // let lastSeen = new Date(Date.now() - 24*60*60*1000);
    let lastSeen = new Date();
    const events = [];

    const push = async () => {

    // ‚îÄ‚îÄ‚îÄ 0) Drop any events that are NOT from today in Asia/Kolkata ‚îÄ‚îÄ‚îÄ new
    const today = getTodayString();
    for (let i = events.length - 1; i >= 0; i--) {
      if (events[i].Dateonly !== today) {
        events.splice(i, 1);
      }
    }


//  console.log('üîÑ [PUSH] Running at:', new Date().toISOString());
  // console.log('üîç Last seen swipe time:', lastSeen);


      const fresh = await fetchNewEvents(lastSeen);

      //  console.log('üì• New events fetched:', fresh.length);




      if (fresh.length) {
        // lastSeen = fresh[fresh.length - 1].LocaleMessageTime;
         lastSeen = new Date();
        events.push(...fresh);
      }
      // else{

      //     console.log('‚ö†Ô∏è No new swipes since lastSeen.');
      // }

    





      // build occupancy + today counts
      const occupancy  = await buildOccupancy(events);
      const todayStats = buildVisitedToday(events);

      occupancy.totalVisitedToday = todayStats.total;
      occupancy.visitedToday      = {
        employees:   todayStats.employees,
        contractors: todayStats.contractors,
        total:       todayStats.total
      };

      //  console.log('üì§ Pushing new occupancy snapshot:', JSON.stringify(occupancy));
      
// occupancy.ertStatus = ertStatus;

// res.write(`data: ${JSON.stringify(occupancy)}\n\n`);


      // add an `id:` so EventSource treats even identical payloads as ‚Äúnew‚Äù
      
      const sid = Date.now();
      res.write(`id: ${sid}\n`);
      res.write(`data: ${JSON.stringify(occupancy)}\n\n`);

    
      if (typeof res.flush === 'function') {
        res.flush();
      }


     };

    await push();
    const timer = setInterval(push, 2000);
    req.on('close', () => clearInterval(timer));

  } catch (err) {
    console.error('Live occupancy SSE error:', err);
    if (!res.headersSent) {
      res.status(500).json({ error: 'Internal Server Error' });
    }
  }
};










// server.js


const express = require('express');
const cors    = require('cors');
const path    = require('path');


const employeeRoutes        = require('./routes/employeeRoutes');
const liveOccupancyRoutes   = require('./routes/liveOccupancyRoutes');
const occupancyDenverRoutes = require('./routes/occupancyDenverRoutes');

const app = express();
app.use(cors());
app.use(express.json());


// --- middleware to disable proxy buffering for SSE endpoints ---
const noBuffering = (req, res, next) => {
  // Nginx or other proxies honor this header to stream chunks immediately
  res.set('X-Accel-Buffering', 'no');
  next();
};


// simple sanity-check
app.get('/ping', (req, res) => res.send('pong'));

app.use('/api', employeeRoutes);

// Pune SSE (live occupancy)
app.use(
  '/api',
  noBuffering,
  liveOccupancyRoutes
);

// Denver SSE (live occupancy)

app.use(
  '/api',
  noBuffering,
  occupancyDenverRoutes
);



// debug: list registered endpoints
if (app._router && Array.isArray(app._router.stack)) {
  console.log('\nüìã Registered endpoints:');
  app._router.stack.forEach(layer => {
    if (layer.route && layer.route.path) {
      const methods = Object
        // .keys(layer.route.methods)
        // .map(m => m.toUpperCase())
        // .join(',');

        .keys(layer.route.methods)
        .map(m => m.toUpperCase())
        .join(',');

      console.log(`  ${methods}\t${layer.route.path}`);
    }
  });
}

// serve React build (if any)
const buildPath = path.join(__dirname, '..', 'client', 'build');
app.use(express.static(buildPath));

// health check
app.get('/health', (req, res) => res.send('OK'));

const PORT = process.env.PORT || 5001;
app.listen(PORT, () => console.log(`Server running at http://localhost:${PORT}`));









C:\Users\W0024618\Desktop\swipeData\client\src\App.js



import React, { useEffect, useState } from 'react';
import { Container, Navbar, Nav } from 'react-bootstrap';
import { BrowserRouter, Routes, Route, Link, useLocation } from 'react-router-dom';
import { FaSun } from 'react-icons/fa';

import ZoneDetailsTable from './components/ZoneDetailsTable';
import DashboardHome    from './pages/DashboardHome';
import ErtPage          from './pages/ErtPage';

import './App.css';

function ZoneDetailsPage({ detailsData }) {
  const [searchTerm, setSearchTerm] = useState('');

  return (
    <>
      <div
        className="d-flex justify-content-between align-items-center mb-2"
        style={{ flexWrap: 'wrap', gap: '0.5rem' }}
      >
        <Link to="/" className="btn btn-secondary">‚Üê Back to Dashboard</Link>
        <input
          type="text"
          placeholder="Search employee..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          style={{ flexGrow: 1, maxWidth: 300, padding: '0.4rem 0.8rem', fontSize: '1rem', borderRadius: 4, border: '1px solid #ccc' }}
        />
      </div>
      <ZoneDetailsTable data={detailsData} searchTerm={searchTerm} />
    </>
  );
}

function App() {
  const location = useLocation();
  const headerText = location.pathname === '/ert'
    ? 'Emergency Response Team ‚Äî Western Union Pune'
    : 'Live Occupancy ‚Äî Western Union Pune';

  // Single state object for the entire payload
  const [liveData, setLiveData] = useState({
    summary: [],
    details: {},
    floorBreakdown: [],
    zoneBreakdown: [],
    personnelBreakdown: [],
    totalVisitedToday: 0,
    personnelSummary: { employees: 0, contractors: 0 },
    visitedToday: { employees: 0, contractors: 0, total: 0 },
    ertStatus: {}
  });

  useEffect(() => {
    const es = new EventSource('http://localhost:5000/api/live-occupancy');

    es.onmessage = (e) => {
      try {
        const p = JSON.parse(e.data);
        // Batch-update entire payload in one setState
        setLiveData({
          summary: Array.isArray(p.summary) ? p.summary : [],
          details: p.details || {},
          floorBreakdown: Array.isArray(p.floorBreakdown) ? p.floorBreakdown : [],
          zoneBreakdown: Array.isArray(p.zoneBreakdown) ? p.zoneBreakdown : [],
          personnelBreakdown: Array.isArray(p.personnelBreakdown) ? p.personnelBreakdown : [],
          totalVisitedToday: typeof p.totalVisitedToday === 'number' ? p.totalVisitedToday : 0,
          personnelSummary: p.personnelSummary || { employees: 0, contractors: 0 },
          visitedToday: p.visitedToday || { employees: 0, contractors: 0, total: 0 },
          ertStatus: p.ertStatus || {}
        });
      } catch {
        console.error('SSE parse error');
      }
    };

    es.onerror = (err) => {
      console.error('SSE error', err);
      es.close();
    };

    return () => es.close();
  }, []);

  return (
    <>
      <Navbar bg="dark" variant="dark" expand="lg" className="px-4">
        <Navbar.Brand as={Link} to="/" className="wu-brand">{headerText}</Navbar.Brand>
        <Nav className="ms-auto align-items-center">
          <Nav.Link as={Link} to="/" className="nav-item-infographic">Dashboard</Nav.Link>
          <Nav.Link as={Link} to="/details" className="nav-item-infographic">Details</Nav.Link>
          <Nav.Link as={Link} to="/ert" className="nav-item-infographic">ERT Overview</Nav.Link>
          <Nav.Link className="theme-toggle-icon" title="Dark mode only"><FaSun/></Nav.Link>
        </Nav>
      </Navbar>

      <Container fluid className="mt-2">
        <Routes>
          <Route
            path="/"
            element={
              <DashboardHome
                summaryData={liveData.summary}
                detailsData={liveData.details}
                floorData={liveData.floorBreakdown}
                zoneBreakdown={liveData.zoneBreakdown}
                personnelBreakdown={liveData.personnelBreakdown}
                totalVisitedToday={liveData.totalVisitedToday}
                personnelSummary={liveData.personnelSummary}
                visitedToday={liveData.visitedToday}
                ertStatus={liveData.ertStatus}
              />
            }
          />
          <Route path="/details" element={<ZoneDetailsPage detailsData={liveData.details} />} />
          <Route path="/ert"     element={<ErtPage ertStatus={liveData.ertStatus} />} />
        </Routes>
      </Container>
    </>
  );
}

export default function WrappedApp() {
  return (
    <BrowserRouter>
      <div className="dark-theme">
        <App />
      </div>
    </BrowserRouter>
  );
}



C:\Users\W0024618\Desktop\swipeData\client\src\pages\DashboardHome.jsx





import React, { useMemo } from 'react';
import { Container, Row, Col } from 'react-bootstrap';

import SummaryCards        from '../components/SummaryCards';
import FloorOccupancyChart from '../components/FloorOccupancyChart';
import SummaryChart        from '../components/SummaryChart';
import PersonnelDonutChart from '../components/PersonnelDonutChart';

function DashboardHome({
  summaryData,
  detailsData,
  floorData,
  zoneBreakdown,
  personnelBreakdown,
  totalVisitedToday,
  personnelSummary,
  visitedToday,
  ertStatus
}) {
  const employees      = personnelSummary?.employees   ?? 0;
  const contractors    = personnelSummary?.contractors ?? 0;
  const totalOccupancy = employees + contractors;

  // Memoize donut-chart data so it only recalculates when personnelBreakdown changes
  const chartData = useMemo(() =>
    (personnelBreakdown || []).map(({ personnelType, count }) => ({ personnelType, count })),
    [personnelBreakdown]
  );

  return (
    <Container fluid className="py-4">
      <SummaryCards
        totalOccupancy={totalOccupancy}
        employeeCount={employees}
        contractorCount={contractors}
        totalVisitedToday={totalVisitedToday}
        employeesVisitedToday={visitedToday?.employees   ?? 0}
        contractorsVisitedToday={visitedToday?.contractors ?? 0}
      />

      <Row className="g-4">
        <Col md={4}>
          <FloorOccupancyChart data={floorData} />
        </Col>

        <Col md={4}>
          <SummaryChart summary={summaryData} />
        </Col>

        <Col md={4}>
          <PersonnelDonutChart data={chartData} />
        </Col>
      </Row>

      <footer style={{
        backgroundColor: '#000',
        color: '#FFC72C',
        padding: '1.5rem 0',
        textAlign: 'center',
        marginTop: '0rem',
        borderTop: '2px solid #FFC72C',
        fontSize: '0.95rem',
        lineHeight: '1.6'
      }}>
        <div><strong>Global Security Operations Center</strong><br/>
          Live HeadCount against Occupancy dashboard for Western Union Pune ‚Äî Real-time occupancy, floor activity, and personnel insights.
        </div>
        <div style={{ marginTop: '0.75rem' }}>
          Contact us:&nbsp;
          <a href="mailto:GSOC-GlobalSecurityOperationCenter.SharedMailbox@westernunion.com"
             style={{ color: '#FFC72C', textDecoration: 'underline' }}>
            GSOC Mail
          </a>&nbsp;|&nbsp;
          Landline:&nbsp;<span style={{ color: '#FFC72C' }}>+91-020-67632394</span>
        </div>
      </footer>
    </Container>
  );
}

// Memoize whole page so it only re-renders when its props actually change
export default React.memo(DashboardHome);





C:\Users\W0024618\Desktop\swipeData\client\src\pages\ErtPage.jsx




import React from 'react';
import { Container, Row, Col } from 'react-bootstrap';
import ERTOverview from '../components/ERTOverview';

function ErtPage({ ertStatus }) {
  return (
    <Container fluid className="py-1">
      <Row className="g-1">
        <Col><ERTOverview ertStatus={ertStatus} /></Col>
      </Row>

      <footer style={{
        backgroundColor: '#000',
        color: '#FFC72C',
        padding: '1.5rem 0',
        textAlign: 'center',
        marginTop: '2rem',
        borderTop: '2px solid #FFC72C',
        fontSize: '0.95rem',
        lineHeight: '1.6'
      }}>
        <div><strong>Global Security Operations Center</strong><br/>
          Live HeadCount against Occupancy dashboard for Western Union Pune ‚Äî Real-time occupancy, floor activity, and personnel insights.
        </div>
        <div style={{ marginTop: '0.75rem' }}>
          Contact us:&nbsp;
          <a href="mailto:GSOC-GlobalSecurityOperationCenter.SharedMailbox@westernunion.com"
             style={{ color: '#FFC72C', textDecoration: 'underline' }}>
            GSOC Mail
          </a>&nbsp;|&nbsp;
          Landline:&nbsp;<span style={{ color: '#FFC72C' }}>+91-020-67632394</span>
        </div>
      </footer>
    </Container>
  );
}

export default React.memo(ErtPage);






C:\Users\W0024618\Desktop\swipeData\client\src\pages\ZoneDeatailsPage.jsx


// // C:\Users\W0024618\Desktop\swipeData\client\src\pages\ZoneDeatailsPage.jsx

// // src/components/ZoneDetailsTable.jsx

// import React, { useState, useMemo } from 'react';
// import './ZoneDetailsTable.css';

// export default function ZoneDetailsTable({ data = {} }) {
//   const [searchTerm, setSearchTerm] = useState('');

//   // 1) Sort zones by descending count
//   const sortedEntries = useMemo(() => {
//     return Object.entries(data).sort(([, aList], [, bList]) => bList.length - aList.length);
//   }, [data]);

//   // 2) Filter predicate
//   const matchesSearch = (emp) =>
//     emp.ObjectName1.toLowerCase().includes(searchTerm.trim().toLowerCase());

//   // 3) Handler for search input
//   const handleSearchChange = (e) => {
//     setSearchTerm(e.target.value);
//   };

//   if (!sortedEntries.length) {
//     return <p>No zone detail data available.</p>;
//   }

//   return (
//     <div className="zone-cards">
//       {/* Search input (optional reuse) */}
//       <div style={{ marginBottom: '1rem', textAlign: 'right' }}>
//         <input
//           type="text"
//           placeholder="Search employee..."
//           value={searchTerm}
//           onChange={handleSearchChange}
//           style={{
//             padding: '0.4rem 0.8rem',
//             fontSize: '0.9rem',
//             borderRadius: 4,
//             border: '1px solid #ccc'
//           }}
//         />
//       </div>

//       {sortedEntries.map(([zone, emps]) => {
//         // 4) Filter employees by search
//         const filteredEmps = emps.filter(matchesSearch);
//         if (filteredEmps.length === 0) {
//           return null;
//         }

//         return (
//           <div key={zone} className="zone-card">
//             <div className="zone-header">
//               <h3>{zone}</h3>
//               <span className="zone-badge">Total: {filteredEmps.length}</span>
//             </div>

//             <table className="zone-table">
//               <thead>
//                 <tr>
//                   <th>Name</th>
//                   <th>Swipe Time</th>
//                   <th>Type</th>
//                   <th>Door Name</th>
//                 </tr>
//               </thead>
//               <tbody>
//                 {filteredEmps.map((emp, i) => (
//                   <tr key={`${emp.EmployeeID}-${i}`}>
//                     <td>{emp.ObjectName1}</td>
//                     <td>{emp.Swipe_Time}</td>
//                     <td>{emp.PersonnelType}</td>
//                     <td>{emp.door}</td>
//                   </tr>
//                 ))}
//               </tbody>
//             </table>
//           </div>
//         );
//       })}
//     </div>
//   );
// }













import React, { useState, useMemo } from 'react';
import './ZoneDetailsTable.css';

function ZoneDetailsTable({ data = {}, searchTerm: outerSearch = '' }) {
  const [searchTerm, setSearchTerm] = useState(outerSearch);

  // 1) Sort zones by descending count (memoized)
  const sortedEntries = useMemo(() => {
    return Object.entries(data).sort(([, aList], [, bList]) => bList.length - aList.length);
  }, [data]);

  // 2) Filter predicate
  const matchesSearch = (emp) =>
    emp.ObjectName1.toLowerCase().includes(searchTerm.trim().toLowerCase());

  // 3) Handler for search input
  const handleSearchChange = (e) => setSearchTerm(e.target.value);

  if (!sortedEntries.length) {
    return <p>No zone detail data available.</p>;
  }

  return (
    <div className="zone-cards">
      <div style={{ marginBottom: '1rem', textAlign: 'right' }}>
        <input
          type="text"
          placeholder="Search employee..."
          value={searchTerm}
          onChange={handleSearchChange}
          style={{ padding: '0.4rem 0.8rem', fontSize: '0.9rem', borderRadius: 4, border: '1px solid #ccc' }}
        />
      </div>

      {sortedEntries.map(([zone, emps]) => {
        const filteredEmps = emps.filter(matchesSearch);
        if (filteredEmps.length === 0) return null;

        return (
          <div key={zone} className="zone-card">
            <div className="zone-header">
              <h3>{zone}</h3>
              <span className="zone-badge">Total: {filteredEmps.length}</span>
            </div>
            <table className="zone-table">
              <thead>
                <tr>
                  <th>Name</th><th>Swipe Time</th><th>Type</th><th>Door Name</th>
                </tr>
              </thead>
              <tbody>
                {filteredEmps.map((emp, i) => (
                  <tr key={`${emp.EmployeeID}-${i}`}>
                    <td>{emp.ObjectName1}</td>
                    <td>{emp.Swipe_Time}</td>
                    <td>{emp.PersonnelType}</td>
                    <td>{emp.door}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        );
      })}
    </div>
  );
}

export default React.memo(ZoneDetailsTable);








