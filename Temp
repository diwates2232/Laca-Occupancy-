// src/components/ChartCard.jsx
import React, { useState, useRef } from 'react';
import { Card, CardContent, Typography, Box } from '@mui/material';
import {
  AreaChart,
  Area,
  Line,
  XAxis,
  YAxis,
  Tooltip,
  ResponsiveContainer,
  CartesianGrid,
  Legend,
  LabelList,
  ReferenceLine,
} from 'recharts';
import dayjs from 'dayjs';

export default function ChartCard({
  title,
  data = [],
  dataKey = 'value',
  chartHeight = 350,
  colors = { head: '#FFC107', cap: '#000000' },
  animateDuration = 800,
  showCrosshair = true,
  timeFormat = 'HH:mm:ss',
  axisProps = {},
  tooltipFormatter = null,
  disableLegendToggle = false,     // prevent hiding via legend click
}) {
  const [hidden, setHidden] = useState({});
  const [activeIndex, setActiveIndex] = useState(null);
  const [replayKey, setReplayKey] = useState(0);
  const containerRef = useRef();

  if (!Array.isArray(data) || !data.length) {
    return (
      <Card sx={{ mb: 2 }}>
        <CardContent sx={{ textAlign: 'center' }}>
          <Typography variant="h6">{title}</Typography>
          <Typography variant="body2">No data to display.</Typography>
        </CardContent>
      </Card>
    );
  }

  const hasCapacity = data[0].Capacity != null;

  // Prevent toggling series off
  const handleLegendClick = o => {
    if (disableLegendToggle) return;
    const { dataKey } = o;
    setHidden(prev => ({ ...prev, [dataKey]: !prev[dataKey] }));
  };

  // Clicking chart area will replay animations
  const handleChartClick = () => {
    setReplayKey(k => k + 1);
  };

  return (
    <Card sx={{ mb: 2 }}>
      <CardContent>
        {/* Title */}
        <Typography variant="h6" gutterBottom sx={{ color: colors.head }}>
          {title}
        </Typography>

        {/* Chart */}
        <Box
          ref={containerRef}
          sx={{ width: '100%', height: chartHeight, cursor: 'pointer' }}
          onClick={handleChartClick}
        >
          <ResponsiveContainer key={replayKey}>
            <AreaChart
              data={data}
              margin={{ top: 20, right: 30, left: 0, bottom: 20 }}
              onMouseMove={e => {
                if (e && e.activeTooltipIndex != null) {
                  setActiveIndex(e.activeTooltipIndex);
                }
              }}
            >
              {/* Gradients */}
              <defs>
                <linearGradient id="colorHead" x1="0" y1="0" x2="0" y2="1">
                  <stop offset="50%" stopColor={colors.head} stopOpacity={0.4} />
                  <stop offset="95%" stopColor={colors.head} stopOpacity={0} />
                </linearGradient>
              </defs>

              {/* Grid */}
              <CartesianGrid strokeDasharray="3 3" stroke="rgba(0,0,0,0.1)" />

              {/* Crosshair */}
              {showCrosshair && activeIndex != null && data[activeIndex] && (
                <ReferenceLine
                  x={data[activeIndex].name}
                  stroke={colors.head}
                  strokeOpacity={0.5}
                />
              )}

              {/* X Axis */}
              <XAxis
                dataKey="name"
                tick={{ fill: '#000', fontWeight: 600 }}
                tickFormatter={t =>
                  typeof t === 'number' ? dayjs(t).format(timeFormat) : t
                }
                label={{
                  value: 'Time',
                  position: 'insideBottomRight',
                  offset: -10,
                  fill: '#000',
                  fontWeight: 600,
                }}
                {...axisProps.xAxis}
              />

              {/* Y Axis */}
              <YAxis
                tick={{ fill: '#000', fontWeight: 600 }}
                label={{
                  value: 'Count',
                  angle: -90,
                  position: 'insideLeft',
                  fill: '#000',
                  fontWeight: 600,
                }}
                {...axisProps.yAxis}
              />

              {/* Tooltip */}
              <Tooltip
                contentStyle={{
                  backgroundColor: '#fff',
                  border: `1px solid ${colors.head}`,
                  padding: '0.5rem',
                }}
                cursor={showCrosshair}
                isAnimationActive={false}
                content={({ active, payload }) => {
                  if (!active || !payload || !payload.length) return null;
                  const { breakdown = {}, name } = payload[0].payload;
                  return (
                    <Box sx={{ backgroundColor: '#fff', border: `1px solid ${colors.head}`, p:1, borderRadius:1 }}>
                      <Typography variant="subtitle2" sx={{ color: colors.head, mb: 0.5 }}>
                        {name}
                      </Typography>
                      {Object.entries(breakdown).map(([key,val])=>(
                        <Typography key={key} variant="body2" sx={{ color: '#000' }}>
                          {key}: {val}
                        </Typography>
                      ))}
                    </Box>
                  );
                }}
              />

              {/* Legend */}
              <Legend
                wrapperStyle={{ color: '#000' }}
                onClick={handleLegendClick}
                iconType="square"
              />

              {/* Capacity Area */}
              {hasCapacity && !hidden.Capacity && (
                <Area
                  type="monotone"
                  dataKey="Capacity"
                  name="Total Seat"
                  stroke={colors.cap}
                  fill={`${colors.cap}33`}
                  dot={false}
                  isAnimationActive
                  animationDuration={animateDuration}
                >
                  <LabelList
                    dataKey="Capacity"
                    position="top"
                    style={{ fill: colors.cap, fontSize: 10, fontWeight: 600 }}
                  />
                </Area>
              )}

              {/* Headcount Area */}
              {!hidden.Headcount && (
                <Area
                  type="monotone"
                  dataKey={hasCapacity ? 'Headcount' : dataKey}
                  name="Usage"
                  stroke={colors.head}
                  fill="url(#colorHead)"
                  dot={false}
                  isAnimationActive
                  animationDuration={animateDuration}
                >
                  <LabelList
                    dataKey={hasCapacity ? 'Headcount' : dataKey}
                    position="top"
                    style={{ fill: '#000', fontSize: 12, fontWeight: 600 }}
                  />
                </Area>
              )}

              {/* Overlay Line */}
              {!hidden.Headcount && (
                <Line
                  type="monotone"
                  dataKey={hasCapacity ? 'Headcount' : dataKey}
                  stroke={colors.head}
                  strokeWidth={2}
                  dot={false}
                  isAnimationActive
                  animationDuration={animateDuration}
                  activeDot={{ r: 6, stroke: '#000', strokeWidth: 2 }}
                />
              )}
            </AreaChart>
          </ResponsiveContainer>
        </Box>
      </CardContent>
    </Card>
  );
}




This is my Current chartCard .jsx now Update this file and Give me updated file carefully.
Add Animation and Hover , On click all animation and share me Updated Files carefully
// src/components/ChartCard.jsx
// import React, { useState } from 'react';
import React, { Fragment, useState } from 'react';
import { Card, CardContent, Typography, Box } from '@mui/material';
import {
  AreaChart,
  Area,
  Line,
  XAxis,
  YAxis,
  Tooltip,
  ResponsiveContainer,
  CartesianGrid,
  Legend,
  Brush,
  LabelList,
  ReferenceLine,
} from 'recharts';
import dayjs from 'dayjs';

export default function ChartCard({
  title,
  data = [],
  dataKey = 'value',
  chartHeight = 350,
  colors = { head: '#FFC107', cap: '#B0BEC5' },
  animateDuration = 800,
  showCrosshair = true,
  timeFormat = 'HH:mm:ss',
    axisProps = {},               // NEW
  tooltipFormatter = null,      // NEW
}) {
  const [hidden, setHidden] = useState({});
  const [activeIndex, setActiveIndex] = useState(null);

  if (!Array.isArray(data) || !data.length) {
    return (
      <Card sx={{ mb: 2 }}>
        <CardContent sx={{ textAlign: 'center' }}>
          <Typography variant="h6">{title}</Typography>
          <Typography variant="body2">No data to display.</Typography>
        </CardContent>
      </Card>
    );
  }

  const hasCapacity = data[0].Capacity != null;
  const handleLegendClick = o => {
    const { dataKey } = o;
    setHidden(prev => ({ ...prev, [dataKey]: !prev[dataKey] }));
  };

  return (
    <Card sx={{ mb: 2 }}>
      <CardContent>
        {/* Chart title */}
        <Typography variant="h6" gutterBottom sx={{ color: colors.head }}>
          {title}
        </Typography>

        {/* Chart container */}
        <Box sx={{ width: '100%', height: chartHeight }}>
          <ResponsiveContainer>
            <AreaChart data={data} margin={{ top: 20, right: 30, left: 0, bottom: 20 }}>
              <defs>
                <linearGradient id="colorHead" x1="0" y1="0" x2="0" y2="1">
                  <stop offset="50%" stopColor={colors.head} stopOpacity={0.4} />
                  <stop offset="95%" stopColor={colors.head} stopOpacity={0} />
                </linearGradient>
              </defs>

              {/* Grid */}
              <CartesianGrid strokeDasharray="3 3" stroke="rgba(255,255,255,0.1)" />

              {/* Crosshair vertical line */}
              {showCrosshair && activeIndex != null && data[activeIndex] && (
                <ReferenceLine
                  x={data[activeIndex].name}
                  stroke={colors.head}
                  strokeOpacity={0.5}
                />
              )}

              <XAxis
                dataKey="name"
                tick={{ fill: '#FFF', fontWeight: 600 }}
                tickFormatter={t => {
                  // if timestamp-like, format; else just return
                  return typeof t === 'number'
                    ? dayjs(t).format(timeFormat)
                    : t;
                    
                }}
                label={{
            
                  position: 'insideBottomRight',
                  offset: -0,
                  fill: '#FFF',
                  fontWeight: 600
                }}
                {...axisProps.xAxis}
              />

              <YAxis
                tick={{ fill: '#FFF', fontWeight: 600 }}
                label={{
                  value: 'Count',
                  angle: -90,
                  position: 'insideLeft',
                  fill: '#FFF',
                  fontWeight: 600
                }}
                 {...axisProps.yAxis}
              />

              {/* Tooltip & Legend */}
               <Tooltip
                contentStyle={{ backgroundColor: '#000', border: `1px solid ${colors.head}`, padding: '1rem' }}
                cursor={showCrosshair}
                isAnimationActive={false}
                onMouseMove={o => setActiveIndex(o && o.activeTooltipIndex)}
             
             
                content={({ active, payload }) => {
   if (!active || !payload || !payload.length) return null;
   const { breakdown = {}, name } = payload[0].payload;
   return (
     <Box
       sx={{
         backgroundColor: '#000',     // ensure black background
         border: `1px solid ${colors.head}`,
        padding: 1,
         borderRadius: 1,
       }}
     >
       <Typography variant="subtitle2" sx={{ color: colors.head, mb: 1 }}>
         {name}
       </Typography>
       {Object.entries(breakdown).map(([key, val]) => (
         <Typography key={key} variant="body2" sx={{ color: '#FFF' }}>
           {key}: {val}
         </Typography>
       ))}
     </Box>
   );
 }}
               />

              <Legend wrapperStyle={{ color: '#FFF' }} onClick={handleLegendClick} />

              {/* Brush for zooming/panning */}
              {/* <Brush
                dataKey="name"
                height={30}
                stroke={colors.head}
                travellerWidth={10}
                updateId={data.length} // reset on data change
              /> */}

              {/* Capacity area */}
              {hasCapacity && !hidden.Capacity && (
                <Area
                  type="monotone"
                  dataKey="Capacity"
                  name="Capacity"
                  stroke={colors.cap}
                  fill={`${colors.cap}33`}
                  dot={false}
                >
                  <LabelList
                    dataKey="Capacity"
                    position="top"
                    style={{ fill: colors.cap, fontSize: 10, fontWeight: 600 }}
                  />
                </Area>
              )}

              {/* Headcount area */}
              {!hidden.Headcount && (
                <Area
                  type="monotone"
                  dataKey={hasCapacity ? 'Headcount' : dataKey}
                  name={hasCapacity ? 'Headcount' : dataKey}
                  stroke={colors.head}
                  fill="url(#colorHead)"
                  dot={false}
                  isAnimationActive
                  animationDuration={animateDuration}
                >
                  <LabelList
                    dataKey={hasCapacity ? 'Headcount' : dataKey}
                    position="top"
                    style={{ fill: '#FFF', fontSize: 12, fontWeight: 600 }}
                  />
                </Area>
              )}

              {/* Overlay line for crisp “spark” */}
              {!hidden.Headcount && (
                <Line
                  type="monotone"
                  dataKey={hasCapacity ? 'Headcount' : dataKey}
                  stroke={colors.head}
                  strokeWidth={2}
                  dot={false}
                  isAnimationActive
                  animationDuration={animateDuration}
                  activeDot={{ r: 6, stroke: '#FFF', strokeWidth: 2 }}
                />
              )}
            </AreaChart>
          </ResponsiveContainer>
        </Box>
      </CardContent>
    </Card>
  );
}






