GET http://localhost:3001/api/occupancy/history


GET http://localhost:3001/api/occupancy/history/CR.SanJose









// src/controllers/occupancy.controller.js

exports.getHistoricalOccupancy = async (req, res) => {
  const location = req.params.location || null;
  try {
    // 1. fetch raw swipes
    const raw = await service.fetchHistoricalOccupancy(location);

    // 2. group by date (YYYY-MM-DD)
    const byDate = raw.reduce((acc, rec) => {
      // ensure we have a string ISO timestamp
      const iso = (rec.LocaleMessageTime instanceof Date)
        ? rec.LocaleMessageTime.toISOString()
        : rec.LocaleMessageTime;
      // extract YYYY-MM-DD
      const d = iso.slice(0, 10);

      acc[d] = acc[d] || [];
      acc[d].push(rec);
      return acc;
    }, {});

    // 3. build summary for each date
    const summaryByDate = Object.keys(byDate)
      .sort()
      .map(date => {
        const recs = byDate[date];
        const regionCounts = { total: 0, Employee: 0, Contractor: 0 };
        const partitionCounts = {};

        recs.forEach(r => {
          regionCounts.total++;
          if (r.PersonnelType === 'Employee') regionCounts.Employee++;
          else regionCounts.Contractor++;

          if (!location) {
            const p = r.PartitionName2;
            partitionCounts[p] = partitionCounts[p] || { total: 0, Employee: 0, Contractor: 0 };
            partitionCounts[p].total++;
            if (r.PersonnelType === 'Employee') partitionCounts[p].Employee++;
            else partitionCounts[p].Contractor++;
          }
        });

        return {
          date,
          day: new Date(date).toLocaleDateString('en-US', { weekday: 'long' }),
          region: location
            ? { name: location, ...regionCounts }
            : { name: 'LACA', ...regionCounts },
          partitions: location ? undefined : partitionCounts
        };
      });

    // 4. respond
    res.json({
      success:     true,
      summaryByDate,
      details:     raw
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'Historical fetch failed' });
  }
};












Read below file carefully annd solve the issue give me updated Snippet,

🚀 Server running on port 3001
✅ MSSQL connected
TypeError: rec.LocaleMessageTime.slice is not a function
    at C:\Users\W0024618\Desktop\laca-occupancy-backend\src\controllers\occupancy.controller.js:98:41
    at Array.reduce (<anonymous>)
    at exports.getHistoricalOccupancy (C:\Users\W0024618\Desktop\laca-occupancy-backend\src\controllers\occupancy.controller.js:96:24)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)






const service = require('../services/occupancy.service');

exports.getLiveOccupancy = async (req, res) => {
  try {
    const data = await service.fetchLiveOccupancy();
    res.json({ success: true, count: data.length, data });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'Live occupancy fetch failed' });
  }
};



/**
 * New: returns a “summary” of who’s currently in-office,
 * plus the same detail list of those still present.
 */
exports.getLiveSummary = async (req, res) => {
  try {
    // 1. get all today’s swipe records
    const allSwipes = await service.fetchLiveOccupancy();

    // 2. pick each person’s last swipe of the day
    const lastByPerson = {};
    allSwipes.forEach(rec => {
      const prev = lastByPerson[rec.PersonGUID];
      if (!prev || new Date(rec.LocaleMessageTime) > new Date(prev.LocaleMessageTime)) {
        lastByPerson[rec.PersonGUID] = rec;
      }
    });



      // 3. filter to those whose last swipe is InDirection (i.e. still in-office)
    const present = Object.values(lastByPerson).filter(r => r.Direction === 'InDirection');

    // 4. build region and per-partition aggregates
    const region = { total: 0, Employee: 0, Contractor: 0 };
    const partitions = {}; // e.g. { 'AR.Cordoba': { total, Employee, Contractor }, … }

    present.forEach(r => {
      // region
      region.total++;
      if (r.PersonnelType === 'Employee') region.Employee++;
      else region.Contractor++;

      // per-partition
      const p = r.PartitionName2;
      if (!partitions[p]) {
        partitions[p] = { total: 0, Employee: 0, Contractor: 0 };
      }
      partitions[p].total++;
      if (r.PersonnelType === 'Employee') partitions[p].Employee++;
      else partitions[p].Contractor++;
    });

    // 5. respond
    res.json({
      success: true,
      summary: {
        region: 'LACA',
        ...region,       // { total, Employee, Contractor }
        partitions       // { 'AR.Cordoba': { … }, … }
      },
      details: present  // the array of swipe‐records still present
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'Live summary fetch failed' });
  }
};


// exports.getHistoricalOccupancy = async (req, res) => {
//   const { location } = req.params;
//   try {
//     const data = await service.fetchHistoricalOccupancy(location);
//     res.json({ success: true, count: data.length, data });
//   } catch (err) {
//     console.error(err);
//     res.status(500).json({ success: false, message: 'Historical occupancy fetch failed' });
//   }
// };




exports.getHistoricalOccupancy = async (req, res) => {
  const location = req.params.location || null;
  try {
    // 1. fetch raw swipes
    const raw = await service.fetchHistoricalOccupancy(location);

    // 2. group by date (YYYY-MM-DD)
    const byDate = raw.reduce((acc, rec) => {
    //   const d = rec.LocaleMessageTime.slice(0,10);
     const time = rec.LocaleMessageTime.slice(11, 16); // e.g., "13:45"
      acc[d] = acc[d] || [];
      acc[d].push(rec);
      return acc;
    }, {});

    // 3. build summary for each date
    const summaryByDate = Object.keys(byDate)
      .sort()
      .map(date => {
        const recs = byDate[date];
        // region or location counts
        const regionCounts = { total: 0, Employee: 0, Contractor: 0 };
        const partitionCounts = {};

        recs.forEach(r => {
          regionCounts.total++;
          if (r.PersonnelType === 'Employee') regionCounts.Employee++;
          else regionCounts.Contractor++;

          if (!location) {
            const p = r.PartitionName2;
            partitionCounts[p] = partitionCounts[p] || { total: 0, Employee: 0, Contractor: 0 };
            partitionCounts[p].total++;
            if (r.PersonnelType === 'Employee') partitionCounts[p].Employee++;
            else partitionCounts[p].Contractor++;
          }
        });

        return {
         date,
          day: new Date(date).toLocaleDateString('en-US', { weekday: 'long' }),
          region: location
            ? { name: location, ...regionCounts }
            : { name: 'LACA', ...regionCounts },
          partitions: location ? undefined : partitionCounts
        };
      });

    // 4. respond
    res.json({
      success:     true,
      summaryByDate,
      details:     raw
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'Historical fetch failed' });
  }
};
