Read below my current file and Give me both Updated files do only necessary changes


C:\Users\W0024618\Desktop\laca-occupancy-backend\src\services\occupancy.service.js


// src/services/occupancy.service.js

const { poolPromise, sql } = require('../config/db');

const partitionList = [
  'AR.Cordoba',
  'BR.Sao Paulo',
  'CR.Costa Rica Partition',
  'MX.Mexico City',
  'PA.Panama City',
  'PE.Lima'
];

/**
 * Fetch live occupancy: today’s CardAdmitted in any of the six partitions,
 * adjusted for each record’s MessageLocaleOffset.
 * Includes Text5 and PartitionName2.
 */
exports.fetchLiveOccupancy = async () => {
  const pool = await poolPromise;
  const partitionsSql = partitionList.map(p => `'${p.replace("'", "''")}'`).join(',');

  const query = `
    WITH CombinedQuery AS (
      SELECT
        DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t1.ObjectName1,
        t1.ObjectName2               AS Door,           -- your original ObjectName2
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor')
            THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END                          AS EmployeeID,
        t2.text5                     AS Text5,          -- ADDED
        t1.PartitionName2            AS PartitionName2, -- ADDED
        t1.ObjectIdentity1           AS PersonGUID,
        t3.Name                      AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          sc.value
        )                             AS CardNumber,
        t5a.value                     AS AdmitCode,
        t5d.value                     AS Direction
      FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLog] AS t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     AS t2 
        ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] AS t3 
        ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] AS t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] AS t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxml] AS t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred]
        WHERE Name IN ('Card','CHUID')
      ) AS sc
        ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType = 'CardAdmitted'
        AND t1.PartitionName2 IN (${partitionsSql})
        AND CONVERT(DATE, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC))
            = CONVERT(DATE, GETDATE())
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8), LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID,
      PersonGUID,
      ObjectName1,
      Door,
      PersonnelType,
      CardNumber,
      Text5,              -- ADDED to final output
      PartitionName2,     -- ADDED to final output
      AdmitCode,
      Direction
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `;

  const result = await pool.request().query(query);
  return result.recordset;
};


/**
 * Fetch historical occupancy: past 30 days for a specific partition/location.
 * Includes Text5 and PartitionName2.
 */


// exports.fetchHistoricalOccupancy = async (location) => {
//   const pool = await poolPromise;

//   const query = `
//     WITH HistoricalData AS (
//       SELECT
//         DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
//         t1.ObjectName1,
//         t1.ObjectName2             AS Door,
//         CASE
//           WHEN t3.Name IN ('Contractor','Terminated Contractor')
//             THEN t2.Text12
//           ELSE CAST(t2.Int1 AS NVARCHAR)
//         END                      AS EmployeeID,
//         t2.text5                 AS Text5,
//         t1.PartitionName2        AS PartitionName2,
//         t1.ObjectIdentity1       AS PersonGUID,
//         t3.Name                  AS PersonnelType,
//         COALESCE(
//           TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
//           TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
//           sc.value
//         )                       AS CardNumber,
//         t5a.value               AS AdmitCode,
//         t5d.value               AS Direction,
//         t1.MessageType
//       FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLog] AS t1
//       LEFT JOIN [ACVSCore].[Access].[Personnel]     AS t2 ON t1.ObjectIdentity1 = t2.GUID
//       LEFT JOIN [ACVSCore].[Access].[PersonnelType] AS t3 ON t2.PersonnelTypeId = t3.ObjectID
//       LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] AS t5a
//         ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
//       LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] AS t5d
//         ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
//       LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxml] AS t_xml
//         ON t1.XmlGUID = t_xml.GUID
//       LEFT JOIN (
//         SELECT GUID, value
//         FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred]
//         WHERE Name IN ('Card','CHUID')
//       ) AS sc
//         ON t1.XmlGUID = sc.GUID
//       WHERE
//         t1.MessageType = 'CardAdmitted'
//         AND t1.PartitionName2 = @location
//         AND CONVERT(DATE, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC))
//           >= DATEADD(DAY, -7, CONVERT(DATE, GETDATE()))
//     )
//     SELECT
//       LocaleMessageTime,
//       CONVERT(DATE, LocaleMessageTime) AS Date,
//       CONVERT(VARCHAR(8), LocaleMessageTime, 108) AS Swipe_Time,
//       ObjectName1,
//       Door,
//       EmployeeID,
//       Text5,
//       PersonGUID,
//       PersonnelType,
//       PartitionName2,
//       CardNumber,
//       AdmitCode,
//       Direction,
//       MessageType
//     FROM HistoricalData
//     ORDER BY LocaleMessageTime ASC;
//   `;

//   const result = await pool.request()
//     .input('location', sql.NVarChar, location)
//     .query(query);

//   return result.recordset;
// };





/**
 * Fetch raw swipe records for the past N days.
 * If `location` is provided, filters to that partition; otherwise all.
 */
exports.fetchHistoricalData = async ({ days = 7, location = null }) => {
  const pool = await poolPromise;
  const partitionsSql = partitionList.map(p => `'${p.replace("'", "''")}'`).join(',');
  const locationFilter = location
    ? `AND t1.PartitionName2 = @location`
    : `AND t1.PartitionName2 IN (${partitionsSql})`;

  const query = `
    WITH Hist AS (
      SELECT
        DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t1.ObjectName1,
        t1.ObjectName2       AS Door,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END                   AS EmployeeID,
        t2.text5             AS Text5,
        t1.PartitionName2    AS PartitionName2,
        t1.ObjectIdentity1   AS PersonGUID,
        t3.Name              AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          sc.value
        )                     AS CardNumber,
        t5a.value            AS AdmitCode,
        t5d.value            AS Direction,
        CONVERT(DATE, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) AS SwipeDate
      FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLog] AS t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     AS t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] AS t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] AS t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] AS t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxml] AS t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred]
        WHERE Name IN ('Card','CHUID')
      ) AS sc
        ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType = 'CardAdmitted'
        ${locationFilter}
        AND CONVERT(DATE, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC))
            >= DATEADD(DAY, -${days}, CONVERT(DATE, GETDATE()))
    )
    SELECT *
    FROM Hist
    ORDER BY LocaleMessageTime ASC;
  `;

  const req = pool.request();
  if (location) req.input('location', sql.NVarChar, location);

  const result = await req.query(query);
  return result.recordset;
};





C:\Users\W0024618\Desktop\laca-occupancy-backend\src\controllers\occupancy.controller.js

const service = require('../services/occupancy.service');

exports.getLiveOccupancy = async (req, res) => {
  try {
    const data = await service.fetchLiveOccupancy();
    res.json({ success: true, count: data.length, data });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'Live occupancy fetch failed' });
  }
};



/**
 * New: returns a “summary” of who’s currently in-office,
 * plus the same detail list of those still present.
 */
exports.getLiveSummary = async (req, res) => {
  try {
    // 1. get all today’s swipe records
    const allSwipes = await service.fetchLiveOccupancy();

    // 2. pick each person’s last swipe of the day
    const lastByPerson = {};
    allSwipes.forEach(rec => {
      const prev = lastByPerson[rec.PersonGUID];
      if (!prev || new Date(rec.LocaleMessageTime) > new Date(prev.LocaleMessageTime)) {
        lastByPerson[rec.PersonGUID] = rec;
      }
    });



      // 3. filter to those whose last swipe is InDirection (i.e. still in-office)
    const present = Object.values(lastByPerson).filter(r => r.Direction === 'InDirection');

    // 4. build region and per-partition aggregates
    const region = { total: 0, Employee: 0, Contractor: 0 };
    const partitions = {}; // e.g. { 'AR.Cordoba': { total, Employee, Contractor }, … }

    present.forEach(r => {
      // region
      region.total++;
      if (r.PersonnelType === 'Employee') region.Employee++;
      else region.Contractor++;

      // per-partition
      const p = r.PartitionName2;
      if (!partitions[p]) {
        partitions[p] = { total: 0, Employee: 0, Contractor: 0 };
      }
      partitions[p].total++;
      if (r.PersonnelType === 'Employee') partitions[p].Employee++;
      else partitions[p].Contractor++;
    });

    // 5. respond
    res.json({
      success: true,
      summary: {
        region: 'LACA',
        ...region,       // { total, Employee, Contractor }
        partitions       // { 'AR.Cordoba': { … }, … }
      },
      details: present  // the array of swipe‐records still present
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'Live summary fetch failed' });
  }
};


exports.getHistoricalOccupancy = async (req, res) => {
  const { location } = req.params;
  try {
    const data = await service.fetchHistoricalOccupancy(location);
    res.json({ success: true, count: data.length, data });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'Historical occupancy fetch failed' });
  }
};


