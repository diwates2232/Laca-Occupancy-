// src/controllers/occupancy.controller.js

const service = require('../services/occupancy.service');
const doorMap = require('../utils/doorMap');

function isEmployeeType(pt) {
  return pt === 'Employee'
      || pt === 'Terminated Employee'
      || pt === 'Terminated Personnel';
}

function isTempBadgeType(pt) {
  return pt === 'Temp Badge';
}

/**
 * Look up floor for a given record by matching door + partition.
 * Returns the floor string or null if unmapped.
 */
function lookupFloor(partition, door, direction, unmappedSet) {
  const entry = doorMap.find(d =>
    d.partition === partition && d.door === door
  );
  if (!entry) {
    // record unmapped for later
    unmappedSet.add(`${partition} | ${door}`);
    return null;
  }
  return direction === 'InDirection'
    ? entry.inDirectionFloor
    : entry.outDirectionFloor;
}

exports.getLiveSummary = async (req, res) => {
  try {
    const swipes = await service.fetchLiveOccupancy();

    // 1. TODAY’S HEADCOUNT: dedupe first swipe
    const firstByPerson = {};
    swipes.forEach(r => {
      const prev = firstByPerson[r.PersonGUID];
      const t = new Date(r.LocaleMessageTime).getTime();
      if (!prev || t < new Date(prev.LocaleMessageTime).getTime()) {
        firstByPerson[r.PersonGUID] = r;
      }
    });
    const todayRecs = Object.values(firstByPerson);

    const todayCounts = { total: 0, Employee: 0, Contractor: 0 };
    todayRecs.forEach(r => {
      todayCounts.total++;
      if (isEmployeeType(r.PersonnelType)) todayCounts.Employee++;
      else todayCounts.Contractor++;
    });

    // 2. REAL-TIME: dedupe last swipe, keep InDirection only
    const lastByPerson = {};
    swipes.forEach(r => {
      const prev = lastByPerson[r.PersonGUID];
      const t = new Date(r.LocaleMessageTime).getTime();
      if (!prev || t > new Date(prev.LocaleMessageTime).getTime()) {
        lastByPerson[r.PersonGUID] = r;
      }
    });

    const realtime = {};
    const unmappedDoors = new Set();

    Object.values(lastByPerson).forEach(r => {
      if (r.Direction !== 'InDirection') return;

      const p = r.PartitionName2;
      realtime[p] = realtime[p] || { total: 0, Employee: 0, Contractor: 0, floors: {} };

      realtime[p].total++;
      if (isEmployeeType(r.PersonnelType)) realtime[p].Employee++;
      else realtime[p].Contractor++;

      const floor = lookupFloor(p, r.Door, r.Direction, unmappedDoors) || 'Unmapped';
      realtime[p].floors[floor] = (realtime[p].floors[floor] || 0) + 1;
    });

    // 3. Log unmapped doors once
    if (unmappedDoors.size) {
      console.warn('Unmapped doors encountered:\n' +
        Array.from(unmappedDoors).join('\n')
      );
    }

    return res.json({
      success: true,
      today: todayCounts,
      realtime,
      details: Object.values(lastByPerson)
    });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ success: false, message: 'Live summary failed' });
  }
};












// src/controllers/occupancy.controller.js

const service = require('../services/occupancy.service');
const doorMap = require('../utils/doorMap');

/**
 * Returns true if this PersonnelType counts as Employee.
 */
function isEmployeeType(pt) {
  return pt === 'Employee'
      || pt === 'Terminated Employee'
      || pt === 'Terminated Personnel';
}

/**
 * True only if this is the Temp Badge category.
 */
function isTempBadgeType(pt) {
  return pt === 'Temp Badge';
}

/**
 * Look up floor for a given record by matching door + direction.
 * Returns the floor string or null if unmapped.
 */
function lookupFloor(partition, door, direction) {
  const entry = doorMap.find(d =>
    d.partition === partition && d.door === door
  );
  if (!entry) {
    console.warn(`Unmapped door: ${partition} / ${door}`);
    return null;
  }
  return direction === 'InDirection'
    ? entry.inDirectionFloor
    : entry.outDirectionFloor;
}

/**
 * GET /api/occupancy/live-summary
 */
exports.getLiveSummary = async (req, res) => {
  try {
    const swipes = await service.fetchLiveOccupancy();

    // TODAY’S HEADCOUNT: dedupe on PersonGUID by FIRST swipe of today
    const firstByPerson = {};
    swipes.forEach(r => {
      const prev = firstByPerson[r.PersonGUID];
      const t = new Date(r.LocaleMessageTime).getTime();
      if (!prev || t < new Date(prev.LocaleMessageTime).getTime()) {
        firstByPerson[r.PersonGUID] = r;
      }
    });
    const todayRecs = Object.values(firstByPerson);

    const todayCounts = { total: 0, Employee: 0, Contractor: 0 };
    todayRecs.forEach(r => {
      todayCounts.total++;
      if (isEmployeeType(r.PersonnelType)) todayCounts.Employee++;
      else todayCounts.Contractor++;
    });

    // REAL-TIME HEADCOUNT: dedupe on PersonGUID by LAST swipe, then count only InDirection
    const lastByPerson = {};
    swipes.forEach(r => {
      const prev = lastByPerson[r.PersonGUID];
      const t = new Date(r.LocaleMessageTime).getTime();
      if (!prev || t > new Date(prev.LocaleMessageTime).getTime()) {
        lastByPerson[r.PersonGUID] = r;
      }
    });

    // Build per-partition → per-floor counts
    const realtime = {}; // { partition: { total, Employee, Contractor, floors: { floorName: count } } }
    Object.values(lastByPerson).forEach(r => {
      if (r.Direction !== 'InDirection') {
        // OutDirection: not currently in office
        return;
      }

      const p = r.PartitionName2;
      realtime[p] = realtime[p] || { total: 0, Employee: 0, Contractor: 0, floors: {} };

      realtime[p].total++;
      if (isEmployeeType(r.PersonnelType)) realtime[p].Employee++;
      else if (isTempBadgeType(r.PersonnelType)) realtime[p].Contractor++;
      else realtime[p].Contractor++;

      const floor = lookupFloor(p, r.Door, r.Direction) || 'Unmapped';
      realtime[p].floors[floor] = (realtime[p].floors[floor] || 0) + 1;
    });

    return res.json({
      success: true,
      today: todayCounts,
      realtime,
      details: Object.values(lastByPerson)
    });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ success: false, message: 'Live summary failed' });
  }
};

// … your existing getHistoricalOccupancy unchanged …











This is my Current file And Give me Updated file carefully.
as per logic .

//C:\Users\W0024618\Desktop\laca-occupancy-backend\src\controllers\occupancy.controller.js


const service = require('../services/occupancy.service');
const doorMap = require('../utils/doorMap');  // your generated mapping

exports.getLiveOccupancy = async (req, res) => {
  try {
    const data = await service.fetchLiveOccupancy();
    res.json({ success: true, count: data.length, data });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'Live occupancy fetch failed' });
  }
};




/**
 * Returns true if this PersonnelType counts as Employee.
 * Everything else (including blank) counts as Contractor.
 */


function isEmployeeType(pt) {
  return pt === 'Employee'
      || pt === 'Terminated Employee'
      || pt === 'Terminated Personnel';
}




/** True only if this is the Temp Badge category. */
function isTempBadgeType(pt) {
  return pt === 'Temp Badge';
}

/**
 * GET /api/occupancy/live-summary
 */
exports.getLiveSummary = async (req, res) => {
  try {
    const swipes = await service.fetchLiveOccupancy();

    // 1. Last swipe per PersonGUID
    const lastByPerson = {};
    swipes.forEach(r => {
      const prev = lastByPerson[r.PersonGUID];
      const now = new Date(r.LocaleMessageTime).getTime();
      if (!prev || now > new Date(prev.LocaleMessageTime).getTime()) {
        lastByPerson[r.PersonGUID] = r;
      }
    });
    const present = Object.values(lastByPerson);

    // 2. Build summary
    const region = { total: 0, Employee: 0, Contractor: 0 };
    const partitions = {};

    present.forEach(r => {
      region.total++;
      if (isEmployeeType(r.PersonnelType)) region.Employee++;
      else region.Contractor++;

      const p = r.PartitionName2;
      // Initialize with the right buckets
      if (!partitions[p]) {
        partitions[p] = p === 'CR.Costa Rica Partition'
          ? { total: 0, Employee: 0, Contractor: 0, TempBadge: 0 }
          : { total: 0, Employee: 0, Contractor: 0 };
      }
      partitions[p].total++;

      // Increment the correct bucket
      if (p === 'CR.Costa Rica Partition') {
        if (isTempBadgeType(r.PersonnelType)) partitions[p].TempBadge++;
        else if (isEmployeeType(r.PersonnelType)) partitions[p].Employee++;
        else partitions[p].Contractor++;
      } else {
        if (isEmployeeType(r.PersonnelType)) partitions[p].Employee++;
        else partitions[p].Contractor++;
      }
    });

    return res.json({
      success: true,
      summary: {
        region: 'LACA',
        ...region,
        partitions
      },
      details: present
    });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ success: false, message: 'Live summary failed' });
  }
};


/**
 * GET /api/occupancy/history[/:location]
 */
exports.getHistoricalOccupancy = async (req, res) => {
  const location = req.params.location || null;
  try {
    const raw = await service.fetchHistoricalOccupancy(location);

    // 1. First swipe per PersonGUID per date
    const byDate = raw.reduce((acc, r) => {
      const iso = (r.LocaleMessageTime instanceof Date)
        ? r.LocaleMessageTime.toISOString()
        : r.LocaleMessageTime;
      const date = iso.slice(0, 10);
      acc[date] = acc[date] || {};
      const prev = acc[date][r.PersonGUID];
      if (!prev || new Date(iso) < new Date(prev.LocaleMessageTime)) {
        acc[date][r.PersonGUID] = { ...r, LocaleMessageTime: iso };
      }
      return acc;
    }, {});

    const summaryByDate = [];
    const details = [];

    // 2. Build per-date summary
    Object.keys(byDate).sort().forEach(date => {
      const recs = Object.values(byDate[date]);
      details.push(...recs);

      const regionCounts = { total: 0, Employee: 0, Contractor: 0 };
      const partitionCounts = {};

      recs.forEach(r => {
        regionCounts.total++;
        if (isEmployeeType(r.PersonnelType)) regionCounts.Employee++;
        else regionCounts.Contractor++;

        const p = r.PartitionName2;
        if (!partitionCounts[p]) {
          partitionCounts[p] = p === 'CR.Costa Rica Partition'
            ? { total: 0, Employee: 0, Contractor: 0, TempBadge: 0 }
            : { total: 0, Employee: 0, Contractor: 0 };
        }
        partitionCounts[p].total++;

        if (p === 'CR.Costa Rica Partition') {
          if (isTempBadgeType(r.PersonnelType)) partitionCounts[p].TempBadge++;
          else if (isEmployeeType(r.PersonnelType)) partitionCounts[p].Employee++;
          else partitionCounts[p].Contractor++;
        } else {
          if (isEmployeeType(r.PersonnelType)) partitionCounts[p].Employee++;
          else partitionCounts[p].Contractor++;
        }
      });

      summaryByDate.push({
        date,
        day: new Date(date).toLocaleDateString('en-US', { weekday: 'long' }),
        region: location
          ? { name: location, ...regionCounts }
          : { name: 'LACA', ...regionCounts },
        partitions: location ? undefined : partitionCounts
      });
    });

    return res.json({
      success: true,
      summaryByDate,
      details
    });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ success: false, message: 'Historical fetch failed' });
  }
};









