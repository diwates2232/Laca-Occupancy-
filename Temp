// src/config/db.js
require('dotenv').config();
const sql = require('mssql');

const {
  DB_USER: rawUser,
  DB_PASSWORD: rawPassword,
  DB_SERVER: rawServer,
  DB_DATABASE: rawDatabase,
  DB_PORT: rawPort
} = process.env;

// Sanity log
console.log(
  'üîç DB CONFIG:',
  `user="${rawUser}"`,
  `server="${rawServer}"`,
  `database="${rawDatabase}"`,
  `port=${rawPort}`
);

const DB_USER     = rawUser.trim();
const DB_PASSWORD = rawPassword.trim();
const DB_SERVER   = rawServer.trim();
const DB_DATABASE = rawDatabase.trim();
const DB_PORT     = parseInt(rawPort.trim(), 10);

const dbConfig = {
  user: DB_USER,                   // SQL Auth username
  password: DB_PASSWORD,           // SQL Auth password
  server: DB_SERVER,               // e.g. "SRVWUFRA0986V"
  port: DB_PORT,                   // e.g. 1433
  database: DB_DATABASE,           // initial catalog
  options: {
    encrypt: false,                // ‚Üê disable TLS
    trustServerCertificate: true,  // ‚Üê accept self-signed certs
    enableArithAbort: true,        // ‚Üê required by newer drivers
  },
  pool: {
    max: 10,
    min: 0,
    idleTimeoutMillis: 30000
  }
};

sql
  .connect(dbConfig)
  .then(pool => {
    console.log('‚úÖ MSSQL connected');
    module.exports = { sql, poolPromise: Promise.resolve(pool) };
  })
  .catch(err => {
    console.error('‚ùå MSSQL connection failed', err);
    process.exit(1);
  });








PS C:\Users\W0024618\Desktop\emea-occupancy-backend> node server.js
DB_USER     = "GSOC_Test"     (length 9)
DB_PASSWORD = "Westernuniongsoc@2025" (length 21)
DB_SERVER   = "SRVWUFRA0986V"   (length 13)
DB_DATABASE = "ACVSUJournal_00010027" (length 21)
DB_PORT     = "1433"     (length 4)
üîç Connecting to SRVWUFRA0986V:1433 DB="ACVSUJournal_00010027" as GSOC_Test
üöÄ Server running on port 3005
‚ùå MSSQL connection failed ConnectionError: Login failed for user 'GSOC_Test'.
    at C:\Users\W0024618\Desktop\emea-occupancy-backend\node_modules\mssql\lib\tedious\connection-pool.js:85:17
    at Connection.onConnect (C:\Users\W0024618\Desktop\emea-occupancy-backend\node_modules\tedious\lib\connection.js:849:9)
    at Object.onceWrapper (node:events:633:26)
    at Connection.emit (node:events:518:28)
    at Connection.emit (C:\Users\W0024618\Desktop\emea-occupancy-backend\node_modules\tedious\lib\connection.js:970:18)
    at C:\Users\W0024618\Desktop\emea-occupancy-backend\node_modules\tedious\lib\connection.js:2369:18
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5) {
  code: 'ELOGIN',
  originalError: ConnectionError: Login failed for user 'GSOC_Test'.
      at Login7TokenHandler.onErrorMessage (C:\Users\W0024618\Desktop\emea-occupancy-backend\node_modules\tedious\lib\token\handler.js:186:19)
      at Readable.<anonymous> (C:\Users\W0024618\Desktop\emea-occupancy-backend\node_modules\tedious\lib\token\token-stream-parser.js:19:33)
      at Readable.emit (node:events:518:28)
      at addChunk (node:internal/streams/readable:561:12)
      at readableAddChunkPushObjectMode (node:internal/streams/readable:538:3)
      at Readable.push (node:internal/streams/readable:393:5)
      at nextAsync (node:internal/streams/from:194:22)
      at process.processTicksAndRejections (node:internal/process/task_queues:105:5) {
    code: 'ELOGIN'
  }
}
PS C:\Users\W0024618\Desktop\emea-occupancy-backend>




// src/config/db.js
require('dotenv').config();
const sql = require('mssql');

// Pull in raw env-vars
const rawUser     = process.env.DB_USER;
const rawPassword = process.env.DB_PASSWORD;
const rawServer   = process.env.DB_SERVER;
const rawDatabase = process.env.DB_DATABASE;
const rawPort     = process.env.DB_PORT;

// Show lengths‚Äîif you‚Äôve got extra spaces/BOM, you‚Äôll see them here
console.log(`DB_USER     = "${rawUser}"     (length ${rawUser?.length})`);
console.log(`DB_PASSWORD = "${rawPassword}" (length ${rawPassword?.length})`);
console.log(`DB_SERVER   = "${rawServer}"   (length ${rawServer?.length})`);
console.log(`DB_DATABASE = "${rawDatabase}" (length ${rawDatabase?.length})`);
console.log(`DB_PORT     = "${rawPort}"     (length ${rawPort?.length})`);

// Trim everything
const DB_USER     = rawUser?.trim();
const DB_PASSWORD = rawPassword?.trim();
const DB_SERVER   = rawServer?.trim();
const DB_DATABASE = rawDatabase?.trim();
const DB_PORT     = parseInt(rawPort?.trim(), 10);

const dbConfig = {
  server: DB_SERVER,
  port:   DB_PORT,
  database: DB_DATABASE,
  authentication: {
    type: 'default',
    options: {
      userName: DB_USER,
      password: DB_PASSWORD
    }
  },
  options: {
    encrypt: true,
    trustServerCertificate: true
  },
  pool: {
    max: 10,
    min: 0,
    idleTimeoutMillis: 30000
  }
};

console.log(
  `üîç Connecting to ${DB_SERVER}:${DB_PORT} ` +
  `DB="${DB_DATABASE}" as ${DB_USER}`
);

sql
  .connect(dbConfig)
  .then(pool => {
    console.log('‚úÖ MSSQL connected');
    module.exports = { sql, poolPromise: Promise.resolve(pool) };
  })
  .catch(err => {
    console.error('‚ùå MSSQL connection failed', err);
    process.exit(1);
  });





// C:\Users\W0024618\Desktop\emea-occupancy-backend\src\controllers\occupancy.controller.js

const service = require('../services/occupancy.service');
const doorMap = require('../utils/doorMap'); 

/**
 * Returns true if this PersonnelType counts as Employee.
 * Everything else (including blank) counts as Contractor.
 */
function isEmployeeType(pt) {
  return pt === 'Employee'
      || pt === 'Terminated Employee'
      || pt === 'Terminated Personnel';
}

/**
 * Look up floor for a given record by matching door + partition.
 */
function lookupFloor(partition, door, direction, unmappedSet) {
  const entry = doorMap.find(d =>
    d.partition === partition && d.door === door
  );
  if (!entry) {
    unmappedSet.add(`${partition} | ${door}`);
    return null;
  }
  return direction === 'InDirection'
    ? entry.inDirectionFloor
    : entry.outDirectionFloor;
}

exports.getLiveOccupancy = async (req, res) => {
  try {
    const data = await service.fetchLiveOccupancy();
    res.json({ success: true, count: data.length, data });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'Live occupancy fetch failed' });
  }
};

exports.getLiveSummary = async (req, res) => {
  try {
    const swipes = await service.fetchLiveOccupancy();

    // 1. TODAY‚ÄôS HEADCOUNT: first swipe per person
    const firstByPerson = {};
    swipes.forEach(r => {
      const prev = firstByPerson[r.PersonGUID];
      const t = new Date(r.LocaleMessageTime).getTime();
      if (!prev || t < new Date(prev.LocaleMessageTime).getTime()) {
        firstByPerson[r.PersonGUID] = r;
      }
    });
    const todayRecs = Object.values(firstByPerson);
    const today = { total: 0, Employee: 0, Contractor: 0 };
    todayRecs.forEach(r => {
      today.total++;
      if (isEmployeeType(r.PersonnelType)) today.Employee++;
      else today.Contractor++;
    });

    // 2. REAL-TIME: last swipe per person, only InDirection
    const lastByPerson = {};
    swipes.forEach(r => {
      const prev = lastByPerson[r.PersonGUID];
      const t = new Date(r.LocaleMessageTime).getTime();
      if (!prev || t > new Date(prev.LocaleMessageTime).getTime()) {
        lastByPerson[r.PersonGUID] = r;
      }
    });

    const realtime = {};
    const unmappedDoors = new Set();
    Object.values(lastByPerson).forEach(r => {
      if (r.Direction !== 'InDirection') return;
      const p = r.PartitionName2;
      // initialize per-partition counters
      if (!realtime[p]) {
        realtime[p] = { total: 0, Employee: 0, Contractor: 0, floors: {} };
      }
      realtime[p].total++;
      if (isEmployeeType(r.PersonnelType)) realtime[p].Employee++;
      else realtime[p].Contractor++;

      const floor = lookupFloor(p, r.Door, r.Direction, unmappedDoors) || 'Unmapped';
      realtime[p].floors[floor] = (realtime[p].floors[floor] || 0) + 1;
    });

    if (unmappedDoors.size) {
      console.warn('Unmapped doors:\n' + Array.from(unmappedDoors).join('\n'));
    }

    return res.json({
      success: true,
      today,
      realtime,
      details: Object.values(lastByPerson)
    });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ success: false, message: 'Live summary failed' });
  }
};

exports.getHistoricalOccupancy = async (req, res) => {
  const location = req.params.location || null;
  try {
    const raw = await service.fetchHistoricalOccupancy(location);

    // first swipe per person per date
    const byDate = raw.reduce((acc, r) => {
      const iso = (r.LocaleMessageTime instanceof Date)
        ? r.LocaleMessageTime.toISOString()
        : r.LocaleMessageTime;
      const date = iso.slice(0,10);
      acc[date] = acc[date] || {};
      const prev = acc[date][r.PersonGUID];
      if (!prev || new Date(iso) < new Date(prev.LocaleMessageTime)) {
        acc[date][r.PersonGUID] = { ...r, LocaleMessageTime: iso };
      }
      return acc;
    }, {});

    const summaryByDate = [];
    const details = [];

    Object.keys(byDate).sort().forEach(date => {
      const recs = Object.values(byDate[date]);
      details.push(...recs);

      // initialize counts
      const regionCounts = { total: 0, Employee: 0, Contractor: 0 };
      const partitionCounts = {};

      recs.forEach(r => {
        regionCounts.total++;
        if (isEmployeeType(r.PersonnelType)) regionCounts.Employee++;
        else regionCounts.Contractor++;

        if (!location) {
          const p = r.PartitionName2;
          if (!partitionCounts[p]) {
            partitionCounts[p] = { total: 0, Employee: 0, Contractor: 0 };
          }
          partitionCounts[p].total++;
          if (isEmployeeType(r.PersonnelType)) partitionCounts[p].Employee++;
          else partitionCounts[p].Contractor++;
        }
      });

      summaryByDate.push({
        date,
        day: new Date(date).toLocaleDateString('en-US', { weekday:'long' }),
        region: location
          ? { name: location, ...regionCounts }
          : { name: 'EMEA', ...regionCounts },
        partitions: location ? undefined : partitionCounts
      });
    });

    return res.json({ success: true, summaryByDate, details });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ success: false, message: 'Historical fetch failed' });
  }
};






C:\Users\W0024618\Desktop\emea-occupancy-backend\src\routes\occupancy.routes.js

const express = require('express');
const router  = express.Router();
const controller = require('../controllers/occupancy.controller');

// Live raw and summary
router.get('/live',         controller.getLiveOccupancy);
router.get('/live-summary', controller.getLiveSummary);

// History: all partitions or a single one
router.get('/history',           controller.getHistoricalOccupancy);
router.get('/history/:location', controller.getHistoricalOccupancy);

module.exports = router;




C:\Users\W0024618\Desktop\emea-occupancy-backend\src\services\occupancy.service.js


const { poolPromise, sql } = require('../config/db');

/**
 * EMEA partition list
 */
const partitionList = [
  'AUT.Vienna',
  'DU.Abu Dhab',
  'IE.Dublin',
  'IT.Rome',
  'LT.Vilnius',
  'MA.Casablanca',
  'RU.Moscow',
  'UK.London'
];

/**
 * Live occupancy (today)
 */
exports.fetchLiveOccupancy = async () => {
  const pool = await poolPromise;
  const partitionsSql = partitionList.map(p => `'${p.replace("'", "''")}'`).join(',');

  const query = `
    WITH CombinedQuery AS (
      SELECT
        DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t1.ObjectName1,
        t1.ObjectName2            AS Door,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor')
            THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END                       AS EmployeeID,
        t2.text5                  AS Text5,
        t1.PartitionName2         AS PartitionName2,
        t1.ObjectIdentity1        AS PersonGUID,
        t3.Name                   AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          sc.value
        )                         AS CardNumber,
        t5a.value                 AS AdmitCode,
        t5d.value                 AS Direction
      FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLog] AS t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     AS t2
        ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] AS t3
        ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] AS t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] AS t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxml] AS t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred]
        WHERE Name IN ('Card','CHUID')
      ) AS sc
        ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType = 'CardAdmitted'
        AND t1.PartitionName2 IN (${partitionsSql})
        AND CONVERT(DATE, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC))
            = CONVERT(DATE, GETDATE())
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8), LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID,
      PersonGUID,
      ObjectName1,
      Door,
      PersonnelType,
      CardNumber,
      Text5,
      PartitionName2,
      AdmitCode,
      Direction
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `;

  const result = await pool.request().query(query);
  return result.recordset;
};

/**
 * Core raw‚Äêdata fetch for the past N days, all or by location.
 */
exports.fetchHistoricalData = async ({ days = 7, location = null }) => {
  const pool = await poolPromise;
  const partitionsSql = partitionList.map(p => `'${p.replace("'", "''")}'`).join(',');
  const locationFilter = location
    ? `AND t1.PartitionName2 = @location`
    : `AND t1.PartitionName2 IN (${partitionsSql})`;

  const query = `
    WITH Hist AS (
      SELECT
        DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t1.ObjectName1,
        t1.ObjectName2       AS Door,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END                   AS EmployeeID,
        t2.text5             AS Text5,
        t1.PartitionName2    AS PartitionName2,
        t1.ObjectIdentity1   AS PersonGUID,
        t3.Name              AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          sc.value
        )                     AS CardNumber,
        t5a.value            AS AdmitCode,
        t5d.value            AS Direction,
        CONVERT(DATE, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) AS SwipeDate
      FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLog] AS t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     AS t2
        ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] AS t3
        ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] AS t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] AS t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxml] AS t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred]
        WHERE Name IN ('Card','CHUID')
      ) AS sc
        ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType = 'CardAdmitted'
        ${locationFilter}
        AND CONVERT(DATE, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC))
            >= DATEADD(DAY, -${days}, CONVERT(DATE, GETDATE()))
    )
    SELECT *
    FROM Hist
    ORDER BY LocaleMessageTime ASC;
  `;

  const req = pool.request();
  if (location) req.input('location', sql.NVarChar, location);
  const result = await req.query(query);
  return result.recordset;
};

/**
 * Public wrapper: always last 7 days, all or by location.
 */
exports.fetchHistoricalOccupancy = async (location) => {
  return exports.fetchHistoricalData({ days: 7, location: location || null });
};

module.exports.partitionList = partitionList;




C:\Users\W0024618\Desktop\emea-occupancy-backend\src\utils\timezones.js


module.exports = {
  'AUT.Vienna':       'Europe/Vienna',
  'DU.Abu Dhab':      'Asia/Dubai',
  'IE.Dublin':        'Europe/Dublin',
  'IT.Rome':          'Europe/Rome',
  'LT.Vilnius':       'Europe/Vilnius',
  'MA.Casablanca':    'Africa/Casablanca',
  'RU.Moscow':        'Europe/Moscow',
  'UK.London':        'Europe/London'
};




// src/app.js
const express = require('express');
const cors    = require('cors');
const occupancyRoutes = require('./routes/occupancy.routes');

const app = express();
app.use(express.json());
app.use(cors());

// Health check
app.get('/', (req, res) => res.send('üåç EMEA Occupancy API Running'));

// Mount our occupancy routes
app.use('/api/occupancy', occupancyRoutes);

module.exports = app;




# .env (must be at C:\Users\W0024618\Desktop\emea-occupancy-backend\.env)
DB_USER=GSOC_Test
DB_PASSWORD=Westernuniongsoc@2025
DB_SERVER=SRVWUFRA0986V
DB_DATABASE=ACVSUJournal_00010027
DB_PORT=1433
PORT=3005





C:\Users\W0024618\Desktop\emea-occupancy-backend\package.json


{
  "name": "emea-occupancy-backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "nodemon src/server.js",
    "start": "node src/server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "cors": "^2.8.5",
    "dotenv": "^16.5.0",
    "express": "^5.1.0",
    "mssql": "^11.0.1",
    "nodemon": "^3.1.10"
  }
}




// server.js (at project root)
require('dotenv').config();           // ‚Üê load .env from project root

const app = require('./src/app');     // ‚Üê now points to src/app.js

const PORT = process.env.PORT || 3005;
app.listen(PORT, () => {
  console.log(`üöÄ Server running on port ${PORT}`);
});




