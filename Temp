// src/controllers/occupancy.controller.js

 const service = require('../services/occupancy.service');

+/**
+ * Returns true if this PersonnelType should count as "Employee"  
+ * (everything else—including blank—counts as Contractor)
+ */
+function isEmployeeType(pt) {
+  return pt === 'Employee' || pt === 'Terminated Employee';
+}

 exports.getLiveSummary = async (req, res) => {
   try {
     const swipes = await service.fetchLiveOccupancy();

     // 1. Dedupe: keep only the last swipe per PersonGUID
     const lastByPerson = {};
     swipes.forEach(rec => {
       const prev = lastByPerson[rec.PersonGUID];
       const curTime = new Date(rec.LocaleMessageTime).getTime();
       if (!prev || curTime > new Date(prev.LocaleMessageTime).getTime()) {
         lastByPerson[rec.PersonGUID] = rec;
       }
     });
     const present = Object.values(lastByPerson);

     // 2. Build summary
     const region = { total: 0, Employee: 0, Contractor: 0 };
     const partitions = {};
     present.forEach(r => {
       region.total++;
-      if (r.PersonnelType === 'Employee') region.Employee++;
-      else region.Contractor++;
+      if (isEmployeeType(r.PersonnelType)) region.Employee++;
+      else region.Contractor++;

       const p = r.PartitionName2;
       if (!partitions[p]) partitions[p] = { total:0, Employee:0, Contractor:0 };
       partitions[p].total++;
-      if (r.PersonnelType==='Employee') partitions[p].Employee++;
-      else partitions[p].Contractor++;
+      if (isEmployeeType(r.PersonnelType)) partitions[p].Employee++;
+      else partitions[p].Contractor++;
     });

     res.json({
       success: true,
       summary: {
         region: 'LACA',
         ...region,
         partitions
       },
       details: present
     });
   } catch (err) {
     console.error(err);
     res.status(500).json({ success:false, message:'Live summary failed' });
   }
 };


 exports.getHistoricalOccupancy = async (req, res) => {
   const location = req.params.location || null;
   try {
     // 1. raw swipes (with SwipeDate as a Date string)
     const raw = await service.fetchHistoricalOccupancy(location);

     // 2. Group by date and dedupe per PersonGUID (first swipe)
     const byDate = raw.reduce((acc, rec) => {
       const iso = (rec.LocaleMessageTime instanceof Date)
         ? rec.LocaleMessageTime.toISOString()
         : rec.LocaleMessageTime;
       const date = iso.slice(0,10);
       acc[date] = acc[date] || { firstByPerson: {} };
       const entry = acc[date];
       if (!entry.firstByPerson[rec.PersonGUID] ||
           new Date(iso) < new Date(entry.firstByPerson[rec.PersonGUID].LocaleMessageTime)
       ) {
         entry.firstByPerson[rec.PersonGUID] = { ...rec, LocaleMessageTime: iso };
       }
       return acc;
     }, {});

     // 3. Build summaryByDate and collect details
     const summaryByDate = [];
     const details = [];

     Object.keys(byDate).sort().forEach(date => {
       const recs = Object.values(byDate[date].firstByPerson);
       details.push(...recs);

       const regionCounts = { total:0, Employee:0, Contractor:0 };
       const partitionCounts = {};

       recs.forEach(r => {
         regionCounts.total++;
-        if (r.PersonnelType === 'Employee') regionCounts.Employee++;
-        else regionCounts.Contractor++;
+        if (isEmployeeType(r.PersonnelType)) regionCounts.Employee++;
+        else regionCounts.Contractor++;

         if (!location) {
           const p = r.PartitionName2;
           if (!partitionCounts[p]) partitionCounts[p] = { total:0, Employee:0, Contractor:0 };
           partitionCounts[p].total++;
-          if (r.PersonnelType==='Employee') partitionCounts[p].Employee++;
-          else partitionCounts[p].Contractor++;
+          if (isEmployeeType(r.PersonnelType)) partitionCounts[p].Employee++;
+          else partitionCounts[p].Contractor++;
         }
       });

       summaryByDate.push({
         date,
         day: new Date(date).toLocaleDateString('en-US', { weekday:'long' }),
         region: location
           ? { name: location, ...regionCounts }
           : { name: 'LACA', ...regionCounts },
         partitions: location ? undefined : partitionCounts
       });
     });

     res.json({
       success: true,
       summaryByDate,
       details
     });
   } catch (err) {
     console.error(err);
     res.status(500).json({ success:false, message:'Historical fetch failed' });
   }
 };

















Read below file carefully 
for Employee 
and Contractor 

their are a cases like 

to build summary- 

if PersonnelType is  Contractor','Terminated Contractor','Temp Badge','Visitor','Property Management or blank 
then increase Contractor count strickly.


PersonnelType is - Employee or Terminated Employee 
then increase Employee count 


Only for build Summary 



for details section keep as it is PersonnelType 

strickly 

make this changes and give me update files carefully .

dont make unne cessary changes carefully.


//C:\Users\W0024618\Desktop\laca-occupancy-backend\src\controllers\occupancy.controller.js


const service = require('../services/occupancy.service');

exports.getLiveOccupancy = async (req, res) => {
  try {
    const data = await service.fetchLiveOccupancy();
    res.json({ success: true, count: data.length, data });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'Live occupancy fetch failed' });
  }
};



/**
 * New: returns a “summary” of who’s currently in-office,
 * plus the same detail list of those still present.
 */


exports.getLiveSummary = async (req, res) => {
  try {
    const swipes = await service.fetchLiveOccupancy();

    // 1. Dedupe: keep only the last swipe per PersonGUID
    const lastByPerson = {};
    swipes.forEach(rec => {
      const prev = lastByPerson[rec.PersonGUID];
      const curTime = new Date(rec.LocaleMessageTime).getTime();
      if (!prev || curTime > new Date(prev.LocaleMessageTime).getTime()) {
        lastByPerson[rec.PersonGUID] = rec;
      }
    });
    const present = Object.values(lastByPerson);

    // 2. Build summary
    const region = { total: 0, Employee: 0, Contractor: 0 };
    const partitions = {};
    present.forEach(r => {
      region.total++;
      if (r.PersonnelType === 'Employee') region.Employee++;
      else region.Contractor++;
      const p = r.PartitionName2;
      if (!partitions[p]) partitions[p] = { total:0, Employee:0, Contractor:0 };
      partitions[p].total++;
      if (r.PersonnelType==='Employee') partitions[p].Employee++;
      else partitions[p].Contractor++;
    });

    res.json({
      success: true,
      summary: {
        region: 'LACA',
        ...region,
        partitions
      },
      details: present
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success:false, message:'Live summary failed' });
  }
};


/**
 * GET /api/occupancy/history or /api/occupancy/history/:location
 *   - Last 7 days of data
 *   - Deduplicate by PersonGUID per date, taking the FIRST swipe of each day
 */
exports.getHistoricalOccupancy = async (req, res) => {
  const location = req.params.location || null;
  try {
    // 1. raw swipes (with SwipeDate as a Date string)
    const raw = await service.fetchHistoricalOccupancy(location);

    // 2. Group by date and dedupe per PersonGUID (first swipe)
    const byDate = raw.reduce((acc, rec) => {
      // normalize LocaleMessageTime to ISO string
      const iso = (rec.LocaleMessageTime instanceof Date)
        ? rec.LocaleMessageTime.toISOString()
        : rec.LocaleMessageTime;
      const date = iso.slice(0,10);
      // ensure map for this date
      acc[date] = acc[date] || { firstByPerson: {}, list: [] };
      const entry = acc[date];
      // if we haven't seen this GUID for this date, or this swipe is earlier
      if (!entry.firstByPerson[rec.PersonGUID] ||
          new Date(iso) < new Date(entry.firstByPerson[rec.PersonGUID].LocaleMessageTime)
      ) {
        entry.firstByPerson[rec.PersonGUID] = { ...rec, LocaleMessageTime: iso };
      }
      return acc;
    }, {});

    // 3. Build summaryByDate and collect details
    const summaryByDate = [];
    const details = [];
    Object.keys(byDate).sort().forEach(date => {
      const { firstByPerson } = byDate[date];
      const recs = Object.values(firstByPerson);
      // push into details
      details.push(...recs);

      // aggregate counts
      const regionCounts = { total:0, Employee:0, Contractor:0 };
      const partitionCounts = {};

      recs.forEach(r => {
        regionCounts.total++;
        if (r.PersonnelType === 'Employee') regionCounts.Employee++;
        else regionCounts.Contractor++;
        if (!location) {
          const p = r.PartitionName2;
          if (!partitionCounts[p]) partitionCounts[p] = { total:0, Employee:0, Contractor:0 };
          partitionCounts[p].total++;
          if (r.PersonnelType==='Employee') partitionCounts[p].Employee++;
          else partitionCounts[p].Contractor++;
        }
      });

      summaryByDate.push({
        date,
        day: new Date(date).toLocaleDateString('en-US', { weekday:'long' }),
        region: location
          ? { name: location, ...regionCounts }
          : { name: 'LACA', ...regionCounts },
        partitions: location ? undefined : partitionCounts
      });
    });

    res.json({
      success: true,
      summaryByDate,
      details
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success:false, message:'Historical fetch failed' });
  }
};




exports.getHistoricalOccupancy = async (req, res) => {
  const location = req.params.location || null;
  try {
    // 1. fetch raw swipes with SwipeDate and LocaleMessageTime from your service
    const raw = await service.fetchHistoricalOccupancy(location);

    // 2. build a map: { dateString: { PersonGUID: firstRec, … }, … }
    const firstByPersonByDate = raw.reduce((acc, rec) => {
      // determine the calendar date key (YYYY-MM-DD) from SwipeDate
      const swipeDate = rec.SwipeDate instanceof Date
        ? rec.SwipeDate.toISOString().slice(0, 10)
        : rec.SwipeDate.slice(0, 10);

      // ensure the day's bucket exists
      if (!acc[swipeDate]) acc[swipeDate] = {};

      const personMap = acc[swipeDate];
      const prev = personMap[rec.PersonGUID];

      // choose the earlier swipe as “first”
      if (
        !prev ||
        new Date(rec.LocaleMessageTime) < new Date(prev.LocaleMessageTime)
      ) {
        personMap[rec.PersonGUID] = rec;
      }

      return acc;
    }, {});

    // 3. build summary and flatten details
    const summaryByDate = [];
    const allDetails = [];

    Object.keys(firstByPersonByDate)
      .sort()
      .forEach(date => {
        const personMap = firstByPersonByDate[date];
        const recs = Object.values(personMap);
        allDetails.push(...recs);

        // count totals
        const regionCounts = { total: 0, Employee: 0, Contractor: 0 };
        const partitionCounts = {};

        recs.forEach(r => {
          regionCounts.total++;
          if (r.PersonnelType === 'Employee') regionCounts.Employee++;
          else regionCounts.Contractor++;

          if (!location) {
            const p = r.PartitionName2;
            if (!partitionCounts[p]) {
              partitionCounts[p] = { total: 0, Employee: 0, Contractor: 0 };
            }
            partitionCounts[p].total++;
            if (r.PersonnelType === 'Employee')
              partitionCounts[p].Employee++;
            else partitionCounts[p].Contractor++;
          }
        });

        summaryByDate.push({
          date,
          day: new Date(date).toLocaleDateString('en-US', { weekday: 'long' }),
          region: location
            ? { name: location, ...regionCounts }
            : { name: 'LACA', ...regionCounts },
          partitions: location ? undefined : partitionCounts
        });
      });

    // 4. respond with deduplicated “first‐swipe” details
    res.json({
      success:     true,
      summaryByDate,
      details:     allDetails
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'Historical fetch failed' });
  }
};













// src/services/occupancy.service.js

const { poolPromise, sql } = require('../config/db');

const partitionList = [
  'AR.Cordoba',
  'BR.Sao Paulo',
  'CR.Costa Rica Partition',
  'MX.Mexico City',
  'PA.Panama City',
  'PE.Lima'
];

/**
 * Live occupancy (today) query unchanged.
 */
exports.fetchLiveOccupancy = async () => {
  const pool = await poolPromise;
  const partitionsSql = partitionList.map(p => `'${p.replace("'", "''")}'`).join(',');

  const query = `
    WITH CombinedQuery AS (
      SELECT
        DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t1.ObjectName1,
        t1.ObjectName2            AS Door,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor')
            THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END                       AS EmployeeID,
        t2.text5                  AS Text5,
        t1.PartitionName2         AS PartitionName2,
        t1.ObjectIdentity1        AS PersonGUID,
        t3.Name                   AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          sc.value
        )                         AS CardNumber,
        t5a.value                 AS AdmitCode,
        t5d.value                 AS Direction
      FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLog] AS t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     AS t2
        ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] AS t3
        ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] AS t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] AS t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxml] AS t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred]
        WHERE Name IN ('Card','CHUID')
      ) AS sc
        ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType = 'CardAdmitted'
        AND t1.PartitionName2 IN (${partitionsSql})
        AND CONVERT(DATE, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC))
            = CONVERT(DATE, GETDATE())
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8), LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID,
      PersonGUID,
      ObjectName1,
      Door,
      PersonnelType,
      CardNumber,
      Text5,
      PartitionName2,
      AdmitCode,
      Direction
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `;

  const result = await pool.request().query(query);
  return result.recordset;
};


/**
 * Core raw‐data fetch for the past N days, all or by location.
 */
exports.fetchHistoricalData = async ({ days = 7, location = null }) => {
  const pool = await poolPromise;
  const partitionsSql = partitionList.map(p => `'${p.replace("'", "''")}'`).join(',');
  const locationFilter = location
    ? `AND t1.PartitionName2 = @location`
    : `AND t1.PartitionName2 IN (${partitionsSql})`;

  const query = `
    WITH Hist AS (
      SELECT
        DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t1.ObjectName1,
        t1.ObjectName2       AS Door,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END                   AS EmployeeID,
        t2.text5             AS Text5,
        t1.PartitionName2    AS PartitionName2,
        t1.ObjectIdentity1   AS PersonGUID,
        t3.Name              AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          sc.value
        )                     AS CardNumber,
        t5a.value            AS AdmitCode,
        t5d.value            AS Direction,
        CONVERT(DATE, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) AS SwipeDate
      FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLog] AS t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     AS t2
        ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] AS t3
        ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] AS t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] AS t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxml] AS t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred]
        WHERE Name IN ('Card','CHUID')
      ) AS sc
        ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType = 'CardAdmitted'
        ${locationFilter}
        AND CONVERT(DATE, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC))
            >= DATEADD(DAY, -${days}, CONVERT(DATE, GETDATE()))
    )
    SELECT *
    FROM Hist
    ORDER BY LocaleMessageTime ASC;
  `;

  const req = pool.request();
  if (location) req.input('location', sql.NVarChar, location);
  const result = await req.query(query);
  return result.recordset;
};


/**
 * Public wrapper: always last 7 days, all or by location.
 */
exports.fetchHistoricalOccupancy = async (location) => {
  return exports.fetchHistoricalData({ days: 30, location: location || null });
};

module.exports.partitionList = partitionList;

