// src/controllers/occupancy.controller.js

const service = require('../services/occupancy.service');

/**
 * Returns true if this PersonnelType should count as "Employee"
 * Everything else (including blank/null) counts as Contractor.
 */
function isEmployeeType(pt) {
  return pt === 'Employee'
      || pt === 'Terminated Employee'
      || pt === 'Terminated Personnel';
}

/**
 * GET /api/occupancy/live-summary
 *   - Deduplicate by PersonGUID, use LAST swipe of today.
 *   - Build summary using isEmployeeType().
 */
exports.getLiveSummary = async (req, res) => {
  try {
    const swipes = await service.fetchLiveOccupancy();

    // 1. Dedupe: keep only the last swipe per PersonGUID
    const lastByPerson = {};
    swipes.forEach(rec => {
      const prev = lastByPerson[rec.PersonGUID];
      const cur = new Date(rec.LocaleMessageTime).getTime();
      if (!prev || cur > new Date(prev.LocaleMessageTime).getTime()) {
        lastByPerson[rec.PersonGUID] = rec;
      }
    });
    const present = Object.values(lastByPerson);

    // 2. Build summary
    const region = { total: 0, Employee: 0, Contractor: 0 };
    const partitions = {};

    present.forEach(r => {
      region.total++;
      if (isEmployeeType(r.PersonnelType)) region.Employee++;
      else region.Contractor++;

      const p = r.PartitionName2;
      if (!partitions[p]) {
        partitions[p] = { total: 0, Employee: 0, Contractor: 0 };
      }
      partitions[p].total++;
      if (isEmployeeType(r.PersonnelType)) partitions[p].Employee++;
      else partitions[p].Contractor++;
    });

    res.json({
      success: true,
      summary: {
        region: 'LACA',
        ...region,
        partitions
      },
      details: present   // original PersonnelType retained here
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'Live summary failed' });
  }
};


/**
 * GET /api/occupancy/history or /api/occupancy/history/:location
 *   - Last 7 days
 *   - Deduplicate by PersonGUID per date, use FIRST swipe of each day.
 *   - Build summary using isEmployeeType().
 */
exports.getHistoricalOccupancy = async (req, res) => {
  const location = req.params.location || null;
  try {
    const raw = await service.fetchHistoricalOccupancy(location);

    // 1. Group & dedupe: first swipe per PersonGUID per date
    const firstByPersonByDate = raw.reduce((acc, rec) => {
      const iso = (rec.LocaleMessageTime instanceof Date)
        ? rec.LocaleMessageTime.toISOString()
        : rec.LocaleMessageTime;
      const date = iso.slice(0, 10);
      acc[date] = acc[date] || {};
      const prev = acc[date][rec.PersonGUID];
      if (!prev || new Date(iso) < new Date(prev.LocaleMessageTime)) {
        acc[date][rec.PersonGUID] = { ...rec, LocaleMessageTime: iso };
      }
      return acc;
    }, {});

    const summaryByDate = [];
    const details = [];

    // 2. Build per-date summary and collect details
    Object.keys(firstByPersonByDate)
      .sort()
      .forEach(date => {
        const recs = Object.values(firstByPersonByDate[date]);
        details.push(...recs);

        const regionCounts = { total: 0, Employee: 0, Contractor: 0 };
        const partitionCounts = {};

        recs.forEach(r => {
          regionCounts.total++;
          if (isEmployeeType(r.PersonnelType)) regionCounts.Employee++;
          else regionCounts.Contractor++;

          if (!location) {
            const p = r.PartitionName2;
            if (!partitionCounts[p]) {
              partitionCounts[p] = { total: 0, Employee: 0, Contractor: 0 };
            }
            partitionCounts[p].total++;
            if (isEmployeeType(r.PersonnelType)) partitionCounts[p].Employee++;
            else partitionCounts[p].Contractor++;
          }
        });

        summaryByDate.push({
          date,
          day: new Date(date).toLocaleDateString('en-US', { weekday: 'long' }),
          region: location
            ? { name: location, ...regionCounts }
            : { name: 'LACA',    ...regionCounts },
          partitions: location ? undefined : partitionCounts
        });
      });

    res.json({
      success: true,
      summaryByDate,
      details              // original PersonnelType retained here
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'Historical fetch failed' });
  }
};












Read below file carefully strickly segrigate Employee , Contractor count as per my request 
and give me updated files carefully



//C:\Users\W0024618\Desktop\laca-occupancy-backend\src\controllers\occupancy.controller.js


const service = require('../services/occupancy.service');

exports.getLiveOccupancy = async (req, res) => {
  try {
    const data = await service.fetchLiveOccupancy();
    res.json({ success: true, count: data.length, data });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'Live occupancy fetch failed' });
  }
};



/**
 * New: returns a “summary” of who’s currently in-office,
 * plus the same detail list of those still present.
 */



/**
 * Helper: decide whether a PersonnelType counts as “Contractor” or “Employee”
 */
function classifyType(pt) {
  const contractorTypes = new Set([
    'Contractor',
    'Terminated Contractor',
    'Temp Badge',
    'Visitor',
    'Property Management',
    '',    // blank
    null
  ]);
  return contractorTypes.has(pt) ? 'Contractor' : 'Employee';
}





/**
 * Returns true if this PersonnelType should count as "Employee"  
 * (everything else—including blank—counts as Contractor)
 */
function isEmployeeType(pt) {
  return pt === 'Employee' || pt === 'Terminated Personnel' || pt ==='Terminated Employee';
}


exports.getLiveSummary = async (req, res) => {
  try {
    const swipes = await service.fetchLiveOccupancy();

    // 1. Dedupe: keep only the last swipe per PersonGUID
    const lastByPerson = {};
    swipes.forEach(rec => {
      const prev = lastByPerson[rec.PersonGUID];
      const curTime = new Date(rec.LocaleMessageTime).getTime();
      if (!prev || curTime > new Date(prev.LocaleMessageTime).getTime()) {
        lastByPerson[rec.PersonGUID] = rec;
      }
    });
    const present = Object.values(lastByPerson);

    // 2. Build summary
    const region = { total: 0, Employee: 0, Contractor: 0 };
    const partitions = {};
    present.forEach(r => {
      region.total++;
    //   if (r.PersonnelType === 'Employee') region.Employee++;
    //   else region.Contractor++;

      if (isEmployeeType(r.PersonnelType)) region.Employee++;
      else region.Contractor++;

      const p = r.PartitionName2;
      if (!partitions[p]) partitions[p] = { total:0, Employee:0, Contractor:0 };
      partitions[p].total++;
    //   if (r.PersonnelType==='Employee') partitions[p].Employee++;
    //   else partitions[p].Contractor++;

    if (isEmployeeType(r.PersonnelType)) partitions[p].Employee++;
      else partitions[p].Contractor++;

    });

    res.json({
      success: true,
      summary: {
        region: 'LACA',
        ...region,
        partitions
      },
      details: present
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success:false, message:'Live summary failed' });
  }
};


/**
 * GET /api/occupancy/history or /api/occupancy/history/:location
 *   - Last 7 days of data
 *   - Deduplicate by PersonGUID per date, taking the FIRST swipe of each day
 */
exports.getHistoricalOccupancy = async (req, res) => {
  const location = req.params.location || null;
  try {
    // 1. raw swipes (with SwipeDate as a Date string)
    const raw = await service.fetchHistoricalOccupancy(location);

    // 2. Group by date and dedupe per PersonGUID (first swipe)
    const byDate = raw.reduce((acc, rec) => {
      // normalize LocaleMessageTime to ISO string
      const iso = (rec.LocaleMessageTime instanceof Date)
        ? rec.LocaleMessageTime.toISOString()
        : rec.LocaleMessageTime;
      const date = iso.slice(0,10);
      // ensure map for this date
      acc[date] = acc[date] || { firstByPerson: {}, list: [] };
      const entry = acc[date];
      // if we haven't seen this GUID for this date, or this swipe is earlier
      if (!entry.firstByPerson[rec.PersonGUID] ||
          new Date(iso) < new Date(entry.firstByPerson[rec.PersonGUID].LocaleMessageTime)
      ) {
        entry.firstByPerson[rec.PersonGUID] = { ...rec, LocaleMessageTime: iso };
      }
      return acc;
    }, {});

    // 3. Build summaryByDate and collect details
    const summaryByDate = [];
    const details = [];
    Object.keys(byDate).sort().forEach(date => {
      const { firstByPerson } = byDate[date];
      const recs = Object.values(firstByPerson);
      // push into details
      details.push(...recs);

      // aggregate counts
      const regionCounts = { total:0, Employee:0, Contractor:0 };
      const partitionCounts = {};

      recs.forEach(r => {
        regionCounts.total++;
        if (r.PersonnelType === 'Employee') regionCounts.Employee++;
        else regionCounts.Contractor++;
        if (!location) {
          const p = r.PartitionName2;
          if (!partitionCounts[p]) partitionCounts[p] = { total:0, Employee:0, Contractor:0 };
          partitionCounts[p].total++;
        //   if (r.PersonnelType==='Employee') partitionCounts[p].Employee++;
        //   else partitionCounts[p].Contractor++;
         if (isEmployeeType(r.PersonnelType)) partitionCounts[p].Employee++;
          else partitionCounts[p].Contractor++;

        }
      });

      summaryByDate.push({
        date,
        day: new Date(date).toLocaleDateString('en-US', { weekday:'long' }),
        region: location
          ? { name: location, ...regionCounts }
          : { name: 'LACA', ...regionCounts },
        partitions: location ? undefined : partitionCounts
      });
    });

    res.json({
      success: true,
      summaryByDate,
      details
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success:false, message:'Historical fetch failed' });
  }
};




exports.getHistoricalOccupancy = async (req, res) => {
  const location = req.params.location || null;
  try {
    // 1. fetch raw swipes with SwipeDate and LocaleMessageTime from your service
    const raw = await service.fetchHistoricalOccupancy(location);

    // 2. build a map: { dateString: { PersonGUID: firstRec, … }, … }
    const firstByPersonByDate = raw.reduce((acc, rec) => {
      // determine the calendar date key (YYYY-MM-DD) from SwipeDate
      const swipeDate = rec.SwipeDate instanceof Date
        ? rec.SwipeDate.toISOString().slice(0, 10)
        : rec.SwipeDate.slice(0, 10);

      // ensure the day's bucket exists
      if (!acc[swipeDate]) acc[swipeDate] = {};

      const personMap = acc[swipeDate];
      const prev = personMap[rec.PersonGUID];

      // choose the earlier swipe as “first”
      if (
        !prev ||
        new Date(rec.LocaleMessageTime) < new Date(prev.LocaleMessageTime)
      ) {
        personMap[rec.PersonGUID] = rec;
      }

      return acc;
    }, {});

    // 3. build summary and flatten details
    const summaryByDate = [];
    const allDetails = [];

    Object.keys(firstByPersonByDate)
      .sort()
      .forEach(date => {
        const personMap = firstByPersonByDate[date];
        const recs = Object.values(personMap);
        allDetails.push(...recs);

        // count totals
        const regionCounts = { total: 0, Employee: 0, Contractor: 0 };
        const partitionCounts = {};

        recs.forEach(r => {
          regionCounts.total++;
        //   if (r.PersonnelType === 'Employee') regionCounts.Employee++;
        //   else regionCounts.Contractor++;
       if (isEmployeeType(r.PersonnelType)) regionCounts.Employee++;
        else regionCounts.Contractor++;



          if (!location) {
            const p = r.PartitionName2;
            if (!partitionCounts[p]) {
              partitionCounts[p] = { total: 0, Employee: 0, Contractor: 0 };
            }
            partitionCounts[p].total++;
            if (r.PersonnelType === 'Employee')
              partitionCounts[p].Employee++;
            else partitionCounts[p].Contractor++;
          }
        });

        summaryByDate.push({
          date,
          day: new Date(date).toLocaleDateString('en-US', { weekday: 'long' }),
          region: location
            ? { name: location, ...regionCounts }
            : { name: 'LACA', ...regionCounts },
          partitions: location ? undefined : partitionCounts
        });
      });

    // 4. respond with deduplicated “first‐swipe” details
    res.json({
      success:     true,
      summaryByDate,
      details:     allDetails
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'Historical fetch failed' });
  }
};
