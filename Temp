Once check all files carefully and update one by one .

PS C:\Users\W0024618\Desktop\emea-occupancy-backend> node src/server.js
üöÄ Server running on port 3005
‚ùå MSSQL connection failed TypeError: The "config.server" property is required and must be of type string.
    at new Connection (C:\Users\W0024618\Desktop\emea-occupancy-backend\node_modules\tedious\lib\connection.js:276:13)
    at C:\Users\W0024618\Desktop\emea-occupancy-backend\node_modules\mssql\lib\tedious\connection-pool.js:78:19
    at new Promise (<anonymous>)
    at ConnectionPool._poolCreate (C:\Users\W0024618\Desktop\emea-occupancy-backend\node_modules\mssql\lib\tedious\connection-pool.js:67:12)
    at ConnectionPool._connect (C:\Users\W0024618\Desktop\emea-occupancy-backend\node_modules\mssql\lib\base\connection-pool.js:446:10)
    at C:\Users\W0024618\Desktop\emea-occupancy-backend\node_modules\mssql\lib\base\connection-pool.js:418:19
    at new Promise (<anonymous>)
    at ConnectionPool.connect (C:\Users\W0024618\Desktop\emea-occupancy-backend\node_modules\mssql\lib\base\connection-pool.js:417:12)
    at Object.<anonymous> (C:\Users\W0024618\Desktop\emea-occupancy-backend\src\config\db.js:22:4)
    at Module._compile (node:internal/modules/cjs/loader:1730:14)



// C:\Users\W0024618\Desktop\emea-occupancy-backend\src\controllers\occupancy.controller.js

const service = require('../services/occupancy.service');
const doorMap = require('../utils/doorMap'); 

/**
 * Returns true if this PersonnelType counts as Employee.
 * Everything else (including blank) counts as Contractor.
 */
function isEmployeeType(pt) {
  return pt === 'Employee'
      || pt === 'Terminated Employee'
      || pt === 'Terminated Personnel';
}

/**
 * Look up floor for a given record by matching door + partition.
 */
function lookupFloor(partition, door, direction, unmappedSet) {
  const entry = doorMap.find(d =>
    d.partition === partition && d.door === door
  );
  if (!entry) {
    unmappedSet.add(`${partition} | ${door}`);
    return null;
  }
  return direction === 'InDirection'
    ? entry.inDirectionFloor
    : entry.outDirectionFloor;
}

exports.getLiveOccupancy = async (req, res) => {
  try {
    const data = await service.fetchLiveOccupancy();
    res.json({ success: true, count: data.length, data });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'Live occupancy fetch failed' });
  }
};

exports.getLiveSummary = async (req, res) => {
  try {
    const swipes = await service.fetchLiveOccupancy();

    // 1. TODAY‚ÄôS HEADCOUNT: first swipe per person
    const firstByPerson = {};
    swipes.forEach(r => {
      const prev = firstByPerson[r.PersonGUID];
      const t = new Date(r.LocaleMessageTime).getTime();
      if (!prev || t < new Date(prev.LocaleMessageTime).getTime()) {
        firstByPerson[r.PersonGUID] = r;
      }
    });
    const todayRecs = Object.values(firstByPerson);
    const today = { total: 0, Employee: 0, Contractor: 0 };
    todayRecs.forEach(r => {
      today.total++;
      if (isEmployeeType(r.PersonnelType)) today.Employee++;
      else today.Contractor++;
    });

    // 2. REAL-TIME: last swipe per person, only InDirection
    const lastByPerson = {};
    swipes.forEach(r => {
      const prev = lastByPerson[r.PersonGUID];
      const t = new Date(r.LocaleMessageTime).getTime();
      if (!prev || t > new Date(prev.LocaleMessageTime).getTime()) {
        lastByPerson[r.PersonGUID] = r;
      }
    });

    const realtime = {};
    const unmappedDoors = new Set();
    Object.values(lastByPerson).forEach(r => {
      if (r.Direction !== 'InDirection') return;
      const p = r.PartitionName2;
      // initialize per-partition counters
      if (!realtime[p]) {
        realtime[p] = { total: 0, Employee: 0, Contractor: 0, floors: {} };
      }
      realtime[p].total++;
      if (isEmployeeType(r.PersonnelType)) realtime[p].Employee++;
      else realtime[p].Contractor++;

      const floor = lookupFloor(p, r.Door, r.Direction, unmappedDoors) || 'Unmapped';
      realtime[p].floors[floor] = (realtime[p].floors[floor] || 0) + 1;
    });

    if (unmappedDoors.size) {
      console.warn('Unmapped doors:\n' + Array.from(unmappedDoors).join('\n'));
    }

    return res.json({
      success: true,
      today,
      realtime,
      details: Object.values(lastByPerson)
    });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ success: false, message: 'Live summary failed' });
  }
};

exports.getHistoricalOccupancy = async (req, res) => {
  const location = req.params.location || null;
  try {
    const raw = await service.fetchHistoricalOccupancy(location);

    // first swipe per person per date
    const byDate = raw.reduce((acc, r) => {
      const iso = (r.LocaleMessageTime instanceof Date)
        ? r.LocaleMessageTime.toISOString()
        : r.LocaleMessageTime;
      const date = iso.slice(0,10);
      acc[date] = acc[date] || {};
      const prev = acc[date][r.PersonGUID];
      if (!prev || new Date(iso) < new Date(prev.LocaleMessageTime)) {
        acc[date][r.PersonGUID] = { ...r, LocaleMessageTime: iso };
      }
      return acc;
    }, {});

    const summaryByDate = [];
    const details = [];

    Object.keys(byDate).sort().forEach(date => {
      const recs = Object.values(byDate[date]);
      details.push(...recs);

      // initialize counts
      const regionCounts = { total: 0, Employee: 0, Contractor: 0 };
      const partitionCounts = {};

      recs.forEach(r => {
        regionCounts.total++;
        if (isEmployeeType(r.PersonnelType)) regionCounts.Employee++;
        else regionCounts.Contractor++;

        if (!location) {
          const p = r.PartitionName2;
          if (!partitionCounts[p]) {
            partitionCounts[p] = { total: 0, Employee: 0, Contractor: 0 };
          }
          partitionCounts[p].total++;
          if (isEmployeeType(r.PersonnelType)) partitionCounts[p].Employee++;
          else partitionCounts[p].Contractor++;
        }
      });

      summaryByDate.push({
        date,
        day: new Date(date).toLocaleDateString('en-US', { weekday:'long' }),
        region: location
          ? { name: location, ...regionCounts }
          : { name: 'EMEA', ...regionCounts },
        partitions: location ? undefined : partitionCounts
      });
    });

    return res.json({ success: true, summaryByDate, details });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ success: false, message: 'Historical fetch failed' });
  }
};






C:\Users\W0024618\Desktop\emea-occupancy-backend\src\server.js

require('dotenv').config();
const app = require('../app');

const PORT = process.env.PORT || 3005;

app.listen(PORT, () => {
  console.log(`üöÄ Server running on port ${PORT}`);
});





C:\Users\W0024618\Desktop\emea-occupancy-backend\app.js

const express = require('express');
const cors    = require('cors');
const occupancyRoutes = require('./src/routes/occupancy.routes');

const app = express();
app.use(express.json());
app.use(cors());

// Health check
app.get('/', (req, res) => res.send('üåç EMEA Occupancy API Running'));

// Routes
app.use('/api/occupancy', occupancyRoutes);

module.exports = app;



C:\Users\W0024618\Desktop\emea-occupancy-backend\src\config\db.js


    const sql = require('mssql');
    require('dotenv').config();

    const dbConfig = {
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    server: process.env.DB_SERVER,
    database: process.env.DB_DATABASE,
    port: parseInt(process.env.DB_PORT, 10),
    options: {
        encrypt: true,
        trustServerCertificate: true
    },
    pool: {
        max: 10,
        min: 0,
        idleTimeoutMillis: 30000
    }
    };

    const poolPromise = new sql.ConnectionPool(dbConfig)
    .connect()
    .then(pool => {
        console.log('‚úÖ MSSQL connected');
        return pool;
    })
    .catch(err => {
        console.error('‚ùå MSSQL connection failed', err);
    });

    module.exports = {
    sql,
    poolPromise
    };




